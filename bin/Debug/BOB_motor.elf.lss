
bin/Debug/BOB_motor.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000e  00800100  00001f46  00001fda  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001f46  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000002ec  0080010e  0080010e  00001fe8  2**0
                  ALLOC
  3 .stab         00003d44  00000000  00000000  00001fe8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00002a1f  00000000  00000000  00005d2c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <__vector_16>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 c0 09 	jmp	0x1380	; 0x1380 <__vector_18>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 53 00 	jmp	0xa6	; 0xa6 <__vector_21>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e6 e4       	ldi	r30, 0x46	; 70
      7c:	ff e1       	ldi	r31, 0x1F	; 31
      7e:	02 c0       	rjmp	.+4      	; 0x84 <.do_copy_data_start>

00000080 <.do_copy_data_loop>:
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0

00000084 <.do_copy_data_start>:
      84:	ae 30       	cpi	r26, 0x0E	; 14
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <.do_copy_data_loop>

0000008a <__do_clear_bss>:
      8a:	13 e0       	ldi	r17, 0x03	; 3
      8c:	ae e0       	ldi	r26, 0x0E	; 14
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	aa 3f       	cpi	r26, 0xFA	; 250
      96:	b1 07       	cpc	r27, r17
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 33 05 	call	0xa66	; 0xa66 <main>
      9e:	0c 94 a1 0f 	jmp	0x1f42	; 0x1f42 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <__vector_21>:
#include "global.h"

//anything that needs to be ran when ever a new conversion happens goes in here
//other wise, simply read from the data registers if data isn't all that important
//aka: you can miss a few bits of data and still be good to go
ISR(ADC_vect) {
      a6:	1f 92       	push	r1
      a8:	0f 92       	push	r0
      aa:	0f b6       	in	r0, 0x3f	; 63
      ac:	0f 92       	push	r0
      ae:	11 24       	eor	r1, r1
      b0:	df 93       	push	r29
      b2:	cf 93       	push	r28
      b4:	cd b7       	in	r28, 0x3d	; 61
      b6:	de b7       	in	r29, 0x3e	; 62
}
      b8:	cf 91       	pop	r28
      ba:	df 91       	pop	r29
      bc:	0f 90       	pop	r0
      be:	0f be       	out	0x3f, r0	; 63
      c0:	0f 90       	pop	r0
      c2:	1f 90       	pop	r1
      c4:	18 95       	reti

000000c6 <adc_start>:

void adc_start(_Bool left) {//Passing a 0 will not left align results
      c6:	df 93       	push	r29
      c8:	cf 93       	push	r28
      ca:	0f 92       	push	r0
      cc:	cd b7       	in	r28, 0x3d	; 61
      ce:	de b7       	in	r29, 0x3e	; 62
      d0:	89 83       	std	Y+1, r24	; 0x01
    ADCSRA |= (1 << ADPS2)
      d2:	aa e7       	ldi	r26, 0x7A	; 122
      d4:	b0 e0       	ldi	r27, 0x00	; 0
      d6:	ea e7       	ldi	r30, 0x7A	; 122
      d8:	f0 e0       	ldi	r31, 0x00	; 0
      da:	80 81       	ld	r24, Z
      dc:	87 60       	ori	r24, 0x07	; 7
      de:	8c 93       	st	X, r24
            | (1 << ADPS1)
            | (1 << ADPS0); // Set ADC prescaler to 128 - 125KHz sample rate @ 16MHz
    ADMUX |= (1 << REFS0); // Set ADC reference to AVCC
      e0:	ac e7       	ldi	r26, 0x7C	; 124
      e2:	b0 e0       	ldi	r27, 0x00	; 0
      e4:	ec e7       	ldi	r30, 0x7C	; 124
      e6:	f0 e0       	ldi	r31, 0x00	; 0
      e8:	80 81       	ld	r24, Z
      ea:	80 64       	ori	r24, 0x40	; 64
      ec:	8c 93       	st	X, r24
    if (left) {
      ee:	89 81       	ldd	r24, Y+1	; 0x01
      f0:	88 23       	and	r24, r24
      f2:	39 f0       	breq	.+14     	; 0x102 <adc_start+0x3c>
        ADMUX |= (1 << ADLAR); // Left adjust ADC result to allow easy 8 bit reading
      f4:	ac e7       	ldi	r26, 0x7C	; 124
      f6:	b0 e0       	ldi	r27, 0x00	; 0
      f8:	ec e7       	ldi	r30, 0x7C	; 124
      fa:	f0 e0       	ldi	r31, 0x00	; 0
      fc:	80 81       	ld	r24, Z
      fe:	80 62       	ori	r24, 0x20	; 32
     100:	8c 93       	st	X, r24
    }
    ADCSRA |= (1 << ADATE);
     102:	aa e7       	ldi	r26, 0x7A	; 122
     104:	b0 e0       	ldi	r27, 0x00	; 0
     106:	ea e7       	ldi	r30, 0x7A	; 122
     108:	f0 e0       	ldi	r31, 0x00	; 0
     10a:	80 81       	ld	r24, Z
     10c:	80 62       	ori	r24, 0x20	; 32
     10e:	8c 93       	st	X, r24
    ADCSRA |= (1 << ADEN);  // Enable ADC
     110:	aa e7       	ldi	r26, 0x7A	; 122
     112:	b0 e0       	ldi	r27, 0x00	; 0
     114:	ea e7       	ldi	r30, 0x7A	; 122
     116:	f0 e0       	ldi	r31, 0x00	; 0
     118:	80 81       	ld	r24, Z
     11a:	80 68       	ori	r24, 0x80	; 128
     11c:	8c 93       	st	X, r24
    ADCSRA |= (1 << ADIE);  // Enable ADC Interrupt
     11e:	aa e7       	ldi	r26, 0x7A	; 122
     120:	b0 e0       	ldi	r27, 0x00	; 0
     122:	ea e7       	ldi	r30, 0x7A	; 122
     124:	f0 e0       	ldi	r31, 0x00	; 0
     126:	80 81       	ld	r24, Z
     128:	88 60       	ori	r24, 0x08	; 8
     12a:	8c 93       	st	X, r24
    sei();
     12c:	78 94       	sei
    ADCSRA |= (1 << ADSC);  // Start A2D Conversions
     12e:	aa e7       	ldi	r26, 0x7A	; 122
     130:	b0 e0       	ldi	r27, 0x00	; 0
     132:	ea e7       	ldi	r30, 0x7A	; 122
     134:	f0 e0       	ldi	r31, 0x00	; 0
     136:	80 81       	ld	r24, Z
     138:	80 64       	ori	r24, 0x40	; 64
     13a:	8c 93       	st	X, r24

}
     13c:	0f 90       	pop	r0
     13e:	cf 91       	pop	r28
     140:	df 91       	pop	r29
     142:	08 95       	ret

00000144 <adc_stop>:

void adc_stop() {
     144:	df 93       	push	r29
     146:	cf 93       	push	r28
     148:	cd b7       	in	r28, 0x3d	; 61
     14a:	de b7       	in	r29, 0x3e	; 62
    //stop the ADC
    ADCSRA &= ~(1 << ADSC);
     14c:	aa e7       	ldi	r26, 0x7A	; 122
     14e:	b0 e0       	ldi	r27, 0x00	; 0
     150:	ea e7       	ldi	r30, 0x7A	; 122
     152:	f0 e0       	ldi	r31, 0x00	; 0
     154:	80 81       	ld	r24, Z
     156:	8f 7b       	andi	r24, 0xBF	; 191
     158:	8c 93       	st	X, r24
}
     15a:	cf 91       	pop	r28
     15c:	df 91       	pop	r29
     15e:	08 95       	ret

00000160 <adc_change>:

void adc_change(char chan) {
     160:	df 93       	push	r29
     162:	cf 93       	push	r28
     164:	00 d0       	rcall	.+0      	; 0x166 <adc_change+0x6>
     166:	0f 92       	push	r0
     168:	cd b7       	in	r28, 0x3d	; 61
     16a:	de b7       	in	r29, 0x3e	; 62
     16c:	89 83       	std	Y+1, r24	; 0x01
    //stop the ADC
    ADCSRA &= ~(1 << ADSC);
     16e:	aa e7       	ldi	r26, 0x7A	; 122
     170:	b0 e0       	ldi	r27, 0x00	; 0
     172:	ea e7       	ldi	r30, 0x7A	; 122
     174:	f0 e0       	ldi	r31, 0x00	; 0
     176:	80 81       	ld	r24, Z
     178:	8f 7b       	andi	r24, 0xBF	; 191
     17a:	8c 93       	st	X, r24
    //and now change the ADMUX bits to fit which channal you want to use
    //sets the MUX0-3 bits inthe ADMUX register
    switch (chan) {
     17c:	89 81       	ldd	r24, Y+1	; 0x01
     17e:	28 2f       	mov	r18, r24
     180:	33 27       	eor	r19, r19
     182:	27 fd       	sbrc	r18, 7
     184:	30 95       	com	r19
     186:	3b 83       	std	Y+3, r19	; 0x03
     188:	2a 83       	std	Y+2, r18	; 0x02
     18a:	8a 81       	ldd	r24, Y+2	; 0x02
     18c:	9b 81       	ldd	r25, Y+3	; 0x03
     18e:	84 33       	cpi	r24, 0x34	; 52
     190:	91 05       	cpc	r25, r1
     192:	09 f4       	brne	.+2      	; 0x196 <adc_change+0x36>
     194:	76 c0       	rjmp	.+236    	; 0x282 <adc_change+0x122>
     196:	2a 81       	ldd	r18, Y+2	; 0x02
     198:	3b 81       	ldd	r19, Y+3	; 0x03
     19a:	25 33       	cpi	r18, 0x35	; 53
     19c:	31 05       	cpc	r19, r1
     19e:	e4 f4       	brge	.+56     	; 0x1d8 <adc_change+0x78>
     1a0:	8a 81       	ldd	r24, Y+2	; 0x02
     1a2:	9b 81       	ldd	r25, Y+3	; 0x03
     1a4:	81 33       	cpi	r24, 0x31	; 49
     1a6:	91 05       	cpc	r25, r1
     1a8:	c1 f1       	breq	.+112    	; 0x21a <adc_change+0xba>
     1aa:	2a 81       	ldd	r18, Y+2	; 0x02
     1ac:	3b 81       	ldd	r19, Y+3	; 0x03
     1ae:	22 33       	cpi	r18, 0x32	; 50
     1b0:	31 05       	cpc	r19, r1
     1b2:	34 f4       	brge	.+12     	; 0x1c0 <adc_change+0x60>
     1b4:	8a 81       	ldd	r24, Y+2	; 0x02
     1b6:	9b 81       	ldd	r25, Y+3	; 0x03
     1b8:	80 33       	cpi	r24, 0x30	; 48
     1ba:	91 05       	cpc	r25, r1
     1bc:	31 f1       	breq	.+76     	; 0x20a <adc_change+0xaa>
     1be:	c7 c0       	rjmp	.+398    	; 0x34e <adc_change+0x1ee>
     1c0:	2a 81       	ldd	r18, Y+2	; 0x02
     1c2:	3b 81       	ldd	r19, Y+3	; 0x03
     1c4:	22 33       	cpi	r18, 0x32	; 50
     1c6:	31 05       	cpc	r19, r1
     1c8:	b9 f1       	breq	.+110    	; 0x238 <adc_change+0xd8>
     1ca:	8a 81       	ldd	r24, Y+2	; 0x02
     1cc:	9b 81       	ldd	r25, Y+3	; 0x03
     1ce:	83 33       	cpi	r24, 0x33	; 51
     1d0:	91 05       	cpc	r25, r1
     1d2:	09 f4       	brne	.+2      	; 0x1d6 <adc_change+0x76>
     1d4:	47 c0       	rjmp	.+142    	; 0x264 <adc_change+0x104>
     1d6:	bb c0       	rjmp	.+374    	; 0x34e <adc_change+0x1ee>
     1d8:	2a 81       	ldd	r18, Y+2	; 0x02
     1da:	3b 81       	ldd	r19, Y+3	; 0x03
     1dc:	26 33       	cpi	r18, 0x36	; 54
     1de:	31 05       	cpc	r19, r1
     1e0:	09 f4       	brne	.+2      	; 0x1e4 <adc_change+0x84>
     1e2:	82 c0       	rjmp	.+260    	; 0x2e8 <adc_change+0x188>
     1e4:	8a 81       	ldd	r24, Y+2	; 0x02
     1e6:	9b 81       	ldd	r25, Y+3	; 0x03
     1e8:	86 33       	cpi	r24, 0x36	; 54
     1ea:	91 05       	cpc	r25, r1
     1ec:	0c f4       	brge	.+2      	; 0x1f0 <adc_change+0x90>
     1ee:	5f c0       	rjmp	.+190    	; 0x2ae <adc_change+0x14e>
     1f0:	2a 81       	ldd	r18, Y+2	; 0x02
     1f2:	3b 81       	ldd	r19, Y+3	; 0x03
     1f4:	27 33       	cpi	r18, 0x37	; 55
     1f6:	31 05       	cpc	r19, r1
     1f8:	09 f4       	brne	.+2      	; 0x1fc <adc_change+0x9c>
     1fa:	8c c0       	rjmp	.+280    	; 0x314 <adc_change+0x1b4>
     1fc:	8a 81       	ldd	r24, Y+2	; 0x02
     1fe:	9b 81       	ldd	r25, Y+3	; 0x03
     200:	88 33       	cpi	r24, 0x38	; 56
     202:	91 05       	cpc	r25, r1
     204:	09 f4       	brne	.+2      	; 0x208 <adc_change+0xa8>
     206:	95 c0       	rjmp	.+298    	; 0x332 <adc_change+0x1d2>
     208:	a2 c0       	rjmp	.+324    	; 0x34e <adc_change+0x1ee>
        case '0'://binary 0
            ADMUX &= ~(1 << MUX0)
     20a:	ac e7       	ldi	r26, 0x7C	; 124
     20c:	b0 e0       	ldi	r27, 0x00	; 0
     20e:	ec e7       	ldi	r30, 0x7C	; 124
     210:	f0 e0       	ldi	r31, 0x00	; 0
     212:	80 81       	ld	r24, Z
     214:	80 7f       	andi	r24, 0xF0	; 240
     216:	8c 93       	st	X, r24
     218:	9a c0       	rjmp	.+308    	; 0x34e <adc_change+0x1ee>
                  &  ~(1 << MUX1)
                  &  ~(1 << MUX2)
                  &  ~(1 << MUX3);
            break;
        case '1'://binary 1
            ADMUX |=  (1 << MUX0);
     21a:	ac e7       	ldi	r26, 0x7C	; 124
     21c:	b0 e0       	ldi	r27, 0x00	; 0
     21e:	ec e7       	ldi	r30, 0x7C	; 124
     220:	f0 e0       	ldi	r31, 0x00	; 0
     222:	80 81       	ld	r24, Z
     224:	81 60       	ori	r24, 0x01	; 1
     226:	8c 93       	st	X, r24
            ADMUX &= ~(1 << MUX1)
     228:	ac e7       	ldi	r26, 0x7C	; 124
     22a:	b0 e0       	ldi	r27, 0x00	; 0
     22c:	ec e7       	ldi	r30, 0x7C	; 124
     22e:	f0 e0       	ldi	r31, 0x00	; 0
     230:	80 81       	ld	r24, Z
     232:	81 7f       	andi	r24, 0xF1	; 241
     234:	8c 93       	st	X, r24
     236:	8b c0       	rjmp	.+278    	; 0x34e <adc_change+0x1ee>
                  &  ~(1 << MUX2)
                  &  ~(1 << MUX3);
            break;
        case '2'://binary 2
            ADMUX &= ~(1 << MUX0);
     238:	ac e7       	ldi	r26, 0x7C	; 124
     23a:	b0 e0       	ldi	r27, 0x00	; 0
     23c:	ec e7       	ldi	r30, 0x7C	; 124
     23e:	f0 e0       	ldi	r31, 0x00	; 0
     240:	80 81       	ld	r24, Z
     242:	8e 7f       	andi	r24, 0xFE	; 254
     244:	8c 93       	st	X, r24
            ADMUX |=  (1 << MUX1);
     246:	ac e7       	ldi	r26, 0x7C	; 124
     248:	b0 e0       	ldi	r27, 0x00	; 0
     24a:	ec e7       	ldi	r30, 0x7C	; 124
     24c:	f0 e0       	ldi	r31, 0x00	; 0
     24e:	80 81       	ld	r24, Z
     250:	82 60       	ori	r24, 0x02	; 2
     252:	8c 93       	st	X, r24
            ADMUX &= ~(1 << MUX2)
     254:	ac e7       	ldi	r26, 0x7C	; 124
     256:	b0 e0       	ldi	r27, 0x00	; 0
     258:	ec e7       	ldi	r30, 0x7C	; 124
     25a:	f0 e0       	ldi	r31, 0x00	; 0
     25c:	80 81       	ld	r24, Z
     25e:	83 7f       	andi	r24, 0xF3	; 243
     260:	8c 93       	st	X, r24
     262:	75 c0       	rjmp	.+234    	; 0x34e <adc_change+0x1ee>
                  &  ~(1 << MUX3);
            break;
        case '3': //should have the picture by now
            ADMUX |=  (1 << MUX0)
     264:	ac e7       	ldi	r26, 0x7C	; 124
     266:	b0 e0       	ldi	r27, 0x00	; 0
     268:	ec e7       	ldi	r30, 0x7C	; 124
     26a:	f0 e0       	ldi	r31, 0x00	; 0
     26c:	80 81       	ld	r24, Z
     26e:	83 60       	ori	r24, 0x03	; 3
     270:	8c 93       	st	X, r24
                  |   (1 << MUX1);
            ADMUX &= ~(1 << MUX2)
     272:	ac e7       	ldi	r26, 0x7C	; 124
     274:	b0 e0       	ldi	r27, 0x00	; 0
     276:	ec e7       	ldi	r30, 0x7C	; 124
     278:	f0 e0       	ldi	r31, 0x00	; 0
     27a:	80 81       	ld	r24, Z
     27c:	83 7f       	andi	r24, 0xF3	; 243
     27e:	8c 93       	st	X, r24
     280:	66 c0       	rjmp	.+204    	; 0x34e <adc_change+0x1ee>
                  &  ~(1 << MUX3);
            break;
        case '4':
            ADMUX &= ~(1 << MUX0)
     282:	ac e7       	ldi	r26, 0x7C	; 124
     284:	b0 e0       	ldi	r27, 0x00	; 0
     286:	ec e7       	ldi	r30, 0x7C	; 124
     288:	f0 e0       	ldi	r31, 0x00	; 0
     28a:	80 81       	ld	r24, Z
     28c:	8c 7f       	andi	r24, 0xFC	; 252
     28e:	8c 93       	st	X, r24
                  &  ~(1 << MUX1);
            ADMUX |=  (1 << MUX2);
     290:	ac e7       	ldi	r26, 0x7C	; 124
     292:	b0 e0       	ldi	r27, 0x00	; 0
     294:	ec e7       	ldi	r30, 0x7C	; 124
     296:	f0 e0       	ldi	r31, 0x00	; 0
     298:	80 81       	ld	r24, Z
     29a:	84 60       	ori	r24, 0x04	; 4
     29c:	8c 93       	st	X, r24
            ADMUX &= ~(1 << MUX3);
     29e:	ac e7       	ldi	r26, 0x7C	; 124
     2a0:	b0 e0       	ldi	r27, 0x00	; 0
     2a2:	ec e7       	ldi	r30, 0x7C	; 124
     2a4:	f0 e0       	ldi	r31, 0x00	; 0
     2a6:	80 81       	ld	r24, Z
     2a8:	87 7f       	andi	r24, 0xF7	; 247
     2aa:	8c 93       	st	X, r24
     2ac:	50 c0       	rjmp	.+160    	; 0x34e <adc_change+0x1ee>
            break;
        case '5':
            ADMUX |=  (1 << MUX0);
     2ae:	ac e7       	ldi	r26, 0x7C	; 124
     2b0:	b0 e0       	ldi	r27, 0x00	; 0
     2b2:	ec e7       	ldi	r30, 0x7C	; 124
     2b4:	f0 e0       	ldi	r31, 0x00	; 0
     2b6:	80 81       	ld	r24, Z
     2b8:	81 60       	ori	r24, 0x01	; 1
     2ba:	8c 93       	st	X, r24
            ADMUX &= ~(1 << MUX1);
     2bc:	ac e7       	ldi	r26, 0x7C	; 124
     2be:	b0 e0       	ldi	r27, 0x00	; 0
     2c0:	ec e7       	ldi	r30, 0x7C	; 124
     2c2:	f0 e0       	ldi	r31, 0x00	; 0
     2c4:	80 81       	ld	r24, Z
     2c6:	8d 7f       	andi	r24, 0xFD	; 253
     2c8:	8c 93       	st	X, r24
            ADMUX |=  (1 << MUX2);
     2ca:	ac e7       	ldi	r26, 0x7C	; 124
     2cc:	b0 e0       	ldi	r27, 0x00	; 0
     2ce:	ec e7       	ldi	r30, 0x7C	; 124
     2d0:	f0 e0       	ldi	r31, 0x00	; 0
     2d2:	80 81       	ld	r24, Z
     2d4:	84 60       	ori	r24, 0x04	; 4
     2d6:	8c 93       	st	X, r24
            ADMUX &= ~(1 << MUX3);
     2d8:	ac e7       	ldi	r26, 0x7C	; 124
     2da:	b0 e0       	ldi	r27, 0x00	; 0
     2dc:	ec e7       	ldi	r30, 0x7C	; 124
     2de:	f0 e0       	ldi	r31, 0x00	; 0
     2e0:	80 81       	ld	r24, Z
     2e2:	87 7f       	andi	r24, 0xF7	; 247
     2e4:	8c 93       	st	X, r24
     2e6:	33 c0       	rjmp	.+102    	; 0x34e <adc_change+0x1ee>
            break;
        case '6':
            ADMUX &= ~(1 << MUX0);
     2e8:	ac e7       	ldi	r26, 0x7C	; 124
     2ea:	b0 e0       	ldi	r27, 0x00	; 0
     2ec:	ec e7       	ldi	r30, 0x7C	; 124
     2ee:	f0 e0       	ldi	r31, 0x00	; 0
     2f0:	80 81       	ld	r24, Z
     2f2:	8e 7f       	andi	r24, 0xFE	; 254
     2f4:	8c 93       	st	X, r24
            ADMUX |=  (1 << MUX1)
     2f6:	ac e7       	ldi	r26, 0x7C	; 124
     2f8:	b0 e0       	ldi	r27, 0x00	; 0
     2fa:	ec e7       	ldi	r30, 0x7C	; 124
     2fc:	f0 e0       	ldi	r31, 0x00	; 0
     2fe:	80 81       	ld	r24, Z
     300:	86 60       	ori	r24, 0x06	; 6
     302:	8c 93       	st	X, r24
                  |   (1 << MUX2);
            ADMUX &= ~(1 << MUX3);
     304:	ac e7       	ldi	r26, 0x7C	; 124
     306:	b0 e0       	ldi	r27, 0x00	; 0
     308:	ec e7       	ldi	r30, 0x7C	; 124
     30a:	f0 e0       	ldi	r31, 0x00	; 0
     30c:	80 81       	ld	r24, Z
     30e:	87 7f       	andi	r24, 0xF7	; 247
     310:	8c 93       	st	X, r24
     312:	1d c0       	rjmp	.+58     	; 0x34e <adc_change+0x1ee>
            break;
        case '7':
            ADMUX |=  (1 << MUX0)
     314:	ac e7       	ldi	r26, 0x7C	; 124
     316:	b0 e0       	ldi	r27, 0x00	; 0
     318:	ec e7       	ldi	r30, 0x7C	; 124
     31a:	f0 e0       	ldi	r31, 0x00	; 0
     31c:	80 81       	ld	r24, Z
     31e:	87 60       	ori	r24, 0x07	; 7
     320:	8c 93       	st	X, r24
                  |   (1 << MUX1)
                  |   (1 << MUX2);
            ADMUX &= ~(1 << MUX3);
     322:	ac e7       	ldi	r26, 0x7C	; 124
     324:	b0 e0       	ldi	r27, 0x00	; 0
     326:	ec e7       	ldi	r30, 0x7C	; 124
     328:	f0 e0       	ldi	r31, 0x00	; 0
     32a:	80 81       	ld	r24, Z
     32c:	87 7f       	andi	r24, 0xF7	; 247
     32e:	8c 93       	st	X, r24
     330:	0e c0       	rjmp	.+28     	; 0x34e <adc_change+0x1ee>
            break;
        case '8':
            ADMUX &= ~(1 << MUX0)
     332:	ac e7       	ldi	r26, 0x7C	; 124
     334:	b0 e0       	ldi	r27, 0x00	; 0
     336:	ec e7       	ldi	r30, 0x7C	; 124
     338:	f0 e0       	ldi	r31, 0x00	; 0
     33a:	80 81       	ld	r24, Z
     33c:	88 7f       	andi	r24, 0xF8	; 248
     33e:	8c 93       	st	X, r24
                  &  ~(1 << MUX1)
                  &  ~(1 << MUX2);
            ADMUX |=  (1 << MUX3);
     340:	ac e7       	ldi	r26, 0x7C	; 124
     342:	b0 e0       	ldi	r27, 0x00	; 0
     344:	ec e7       	ldi	r30, 0x7C	; 124
     346:	f0 e0       	ldi	r31, 0x00	; 0
     348:	80 81       	ld	r24, Z
     34a:	88 60       	ori	r24, 0x08	; 8
     34c:	8c 93       	st	X, r24
            break;
    }
    //re-enable ADC conversions now that the channel is selected
    ADCSRA |= (1 << ADSC);
     34e:	aa e7       	ldi	r26, 0x7A	; 122
     350:	b0 e0       	ldi	r27, 0x00	; 0
     352:	ea e7       	ldi	r30, 0x7A	; 122
     354:	f0 e0       	ldi	r31, 0x00	; 0
     356:	80 81       	ld	r24, Z
     358:	80 64       	ori	r24, 0x40	; 64
     35a:	8c 93       	st	X, r24
}
     35c:	0f 90       	pop	r0
     35e:	0f 90       	pop	r0
     360:	0f 90       	pop	r0
     362:	cf 91       	pop	r28
     364:	df 91       	pop	r29
     366:	08 95       	ret

00000368 <bios>:
            break;
    }
}
*/

void bios(void) {
     368:	df 93       	push	r29
     36a:	cf 93       	push	r28
     36c:	cd b7       	in	r28, 0x3d	; 61
     36e:	de b7       	in	r29, 0x3e	; 62
    DDRD |= (1<<CPU_POW); //CPU power led to output, and turn it on
     370:	aa e2       	ldi	r26, 0x2A	; 42
     372:	b0 e0       	ldi	r27, 0x00	; 0
     374:	ea e2       	ldi	r30, 0x2A	; 42
     376:	f0 e0       	ldi	r31, 0x00	; 0
     378:	80 81       	ld	r24, Z
     37a:	84 60       	ori	r24, 0x04	; 4
     37c:	8c 93       	st	X, r24
    PORTD |= (1<<CPU_POW);
     37e:	ab e2       	ldi	r26, 0x2B	; 43
     380:	b0 e0       	ldi	r27, 0x00	; 0
     382:	eb e2       	ldi	r30, 0x2B	; 43
     384:	f0 e0       	ldi	r31, 0x00	; 0
     386:	80 81       	ld	r24, Z
     388:	84 60       	ori	r24, 0x04	; 4
     38a:	8c 93       	st	X, r24

    DDRD |= (1<<stat_led1);//stat led one
     38c:	aa e2       	ldi	r26, 0x2A	; 42
     38e:	b0 e0       	ldi	r27, 0x00	; 0
     390:	ea e2       	ldi	r30, 0x2A	; 42
     392:	f0 e0       	ldi	r31, 0x00	; 0
     394:	80 81       	ld	r24, Z
     396:	80 62       	ori	r24, 0x20	; 32
     398:	8c 93       	st	X, r24
    DDRD |= (1<<stat_led2);//stat led two
     39a:	aa e2       	ldi	r26, 0x2A	; 42
     39c:	b0 e0       	ldi	r27, 0x00	; 0
     39e:	ea e2       	ldi	r30, 0x2A	; 42
     3a0:	f0 e0       	ldi	r31, 0x00	; 0
     3a2:	80 81       	ld	r24, Z
     3a4:	80 64       	ori	r24, 0x40	; 64
     3a6:	8c 93       	st	X, r24
    DDRD |= (1<<turn_relay);//turn relay pin to output
     3a8:	aa e2       	ldi	r26, 0x2A	; 42
     3aa:	b0 e0       	ldi	r27, 0x00	; 0
     3ac:	ea e2       	ldi	r30, 0x2A	; 42
     3ae:	f0 e0       	ldi	r31, 0x00	; 0
     3b0:	80 81       	ld	r24, Z
     3b2:	84 60       	ori	r24, 0x04	; 4
     3b4:	8c 93       	st	X, r24
    DDRD |= (1<<drive_relay);//drive relay pin to output
     3b6:	aa e2       	ldi	r26, 0x2A	; 42
     3b8:	b0 e0       	ldi	r27, 0x00	; 0
     3ba:	ea e2       	ldi	r30, 0x2A	; 42
     3bc:	f0 e0       	ldi	r31, 0x00	; 0
     3be:	80 81       	ld	r24, Z
     3c0:	88 60       	ori	r24, 0x08	; 8
     3c2:	8c 93       	st	X, r24

    pwm_setup_all(); //start all the pwm channels
     3c4:	0e 94 45 05 	call	0xa8a	; 0xa8a <pwm_setup_all>
    adc_start(1); //start the adc converters
     3c8:	81 e0       	ldi	r24, 0x01	; 1
     3ca:	0e 94 63 00 	call	0xc6	; 0xc6 <adc_start>
    uart_start(); //start the UART interface
     3ce:	0e 94 e1 08 	call	0x11c2	; 0x11c2 <uart_start>
    twi_start(); //start the TWI/I2C interface
     3d2:	0e 94 9d 03 	call	0x73a	; 0x73a <twi_start>

    DDRD |= (0<<3)
     3d6:	aa e2       	ldi	r26, 0x2A	; 42
     3d8:	b0 e0       	ldi	r27, 0x00	; 0
     3da:	ea e2       	ldi	r30, 0x2A	; 42
     3dc:	f0 e0       	ldi	r31, 0x00	; 0
     3de:	80 81       	ld	r24, Z
     3e0:	8c 93       	st	X, r24
         |  (0<<4); //setup the button pins as inputs

    setup_timer0();
     3e2:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <setup_timer0>

}
     3e6:	cf 91       	pop	r28
     3e8:	df 91       	pop	r29
     3ea:	08 95       	ret

000003ec <portB_out>:
freenode/#linuxandsci - JoshAshby
*/
//-------------------------------------------
#include "global.h"

void portB_out(int pin, _Bool value) {
     3ec:	df 93       	push	r29
     3ee:	cf 93       	push	r28
     3f0:	00 d0       	rcall	.+0      	; 0x3f2 <portB_out+0x6>
     3f2:	0f 92       	push	r0
     3f4:	cd b7       	in	r28, 0x3d	; 61
     3f6:	de b7       	in	r29, 0x3e	; 62
     3f8:	9a 83       	std	Y+2, r25	; 0x02
     3fa:	89 83       	std	Y+1, r24	; 0x01
     3fc:	6b 83       	std	Y+3, r22	; 0x03
    /*
    Change the state of a pin on PORTB
    simply pass the pin number, and either a 0 to sink current or 1 to source it
    */
    if (value == 0) {
     3fe:	8b 81       	ldd	r24, Y+3	; 0x03
     400:	91 e0       	ldi	r25, 0x01	; 1
     402:	89 27       	eor	r24, r25
     404:	88 23       	and	r24, r24
     406:	91 f0       	breq	.+36     	; 0x42c <portB_out+0x40>
        PORTB &= ~(1<<pin);
     408:	a5 e2       	ldi	r26, 0x25	; 37
     40a:	b0 e0       	ldi	r27, 0x00	; 0
     40c:	e5 e2       	ldi	r30, 0x25	; 37
     40e:	f0 e0       	ldi	r31, 0x00	; 0
     410:	80 81       	ld	r24, Z
     412:	28 2f       	mov	r18, r24
     414:	81 e0       	ldi	r24, 0x01	; 1
     416:	90 e0       	ldi	r25, 0x00	; 0
     418:	09 80       	ldd	r0, Y+1	; 0x01
     41a:	02 c0       	rjmp	.+4      	; 0x420 <portB_out+0x34>
     41c:	88 0f       	add	r24, r24
     41e:	99 1f       	adc	r25, r25
     420:	0a 94       	dec	r0
     422:	e2 f7       	brpl	.-8      	; 0x41c <portB_out+0x30>
     424:	80 95       	com	r24
     426:	82 23       	and	r24, r18
     428:	8c 93       	st	X, r24
     42a:	10 c0       	rjmp	.+32     	; 0x44c <portB_out+0x60>
    } else  {
        PORTB |= (1<<pin);
     42c:	a5 e2       	ldi	r26, 0x25	; 37
     42e:	b0 e0       	ldi	r27, 0x00	; 0
     430:	e5 e2       	ldi	r30, 0x25	; 37
     432:	f0 e0       	ldi	r31, 0x00	; 0
     434:	80 81       	ld	r24, Z
     436:	28 2f       	mov	r18, r24
     438:	81 e0       	ldi	r24, 0x01	; 1
     43a:	90 e0       	ldi	r25, 0x00	; 0
     43c:	09 80       	ldd	r0, Y+1	; 0x01
     43e:	02 c0       	rjmp	.+4      	; 0x444 <portB_out+0x58>
     440:	88 0f       	add	r24, r24
     442:	99 1f       	adc	r25, r25
     444:	0a 94       	dec	r0
     446:	e2 f7       	brpl	.-8      	; 0x440 <portB_out+0x54>
     448:	82 2b       	or	r24, r18
     44a:	8c 93       	st	X, r24
    }
}
     44c:	0f 90       	pop	r0
     44e:	0f 90       	pop	r0
     450:	0f 90       	pop	r0
     452:	cf 91       	pop	r28
     454:	df 91       	pop	r29
     456:	08 95       	ret

00000458 <portD_out>:

void portD_out(int pin, _Bool value) {
     458:	df 93       	push	r29
     45a:	cf 93       	push	r28
     45c:	00 d0       	rcall	.+0      	; 0x45e <portD_out+0x6>
     45e:	0f 92       	push	r0
     460:	cd b7       	in	r28, 0x3d	; 61
     462:	de b7       	in	r29, 0x3e	; 62
     464:	9a 83       	std	Y+2, r25	; 0x02
     466:	89 83       	std	Y+1, r24	; 0x01
     468:	6b 83       	std	Y+3, r22	; 0x03
    /*
    Change the state of a pin on PORTD
    simply pass the pin number, and either a 0 to sink current or 1 to source it
    */
    if (value == 0) {
     46a:	8b 81       	ldd	r24, Y+3	; 0x03
     46c:	91 e0       	ldi	r25, 0x01	; 1
     46e:	89 27       	eor	r24, r25
     470:	88 23       	and	r24, r24
     472:	91 f0       	breq	.+36     	; 0x498 <portD_out+0x40>
        PORTD &= ~(1<<pin);
     474:	ab e2       	ldi	r26, 0x2B	; 43
     476:	b0 e0       	ldi	r27, 0x00	; 0
     478:	eb e2       	ldi	r30, 0x2B	; 43
     47a:	f0 e0       	ldi	r31, 0x00	; 0
     47c:	80 81       	ld	r24, Z
     47e:	28 2f       	mov	r18, r24
     480:	81 e0       	ldi	r24, 0x01	; 1
     482:	90 e0       	ldi	r25, 0x00	; 0
     484:	09 80       	ldd	r0, Y+1	; 0x01
     486:	02 c0       	rjmp	.+4      	; 0x48c <portD_out+0x34>
     488:	88 0f       	add	r24, r24
     48a:	99 1f       	adc	r25, r25
     48c:	0a 94       	dec	r0
     48e:	e2 f7       	brpl	.-8      	; 0x488 <portD_out+0x30>
     490:	80 95       	com	r24
     492:	82 23       	and	r24, r18
     494:	8c 93       	st	X, r24
     496:	10 c0       	rjmp	.+32     	; 0x4b8 <portD_out+0x60>
    } else {
        PORTD |= (1<<pin);
     498:	ab e2       	ldi	r26, 0x2B	; 43
     49a:	b0 e0       	ldi	r27, 0x00	; 0
     49c:	eb e2       	ldi	r30, 0x2B	; 43
     49e:	f0 e0       	ldi	r31, 0x00	; 0
     4a0:	80 81       	ld	r24, Z
     4a2:	28 2f       	mov	r18, r24
     4a4:	81 e0       	ldi	r24, 0x01	; 1
     4a6:	90 e0       	ldi	r25, 0x00	; 0
     4a8:	09 80       	ldd	r0, Y+1	; 0x01
     4aa:	02 c0       	rjmp	.+4      	; 0x4b0 <portD_out+0x58>
     4ac:	88 0f       	add	r24, r24
     4ae:	99 1f       	adc	r25, r25
     4b0:	0a 94       	dec	r0
     4b2:	e2 f7       	brpl	.-8      	; 0x4ac <portD_out+0x54>
     4b4:	82 2b       	or	r24, r18
     4b6:	8c 93       	st	X, r24
    }
}
     4b8:	0f 90       	pop	r0
     4ba:	0f 90       	pop	r0
     4bc:	0f 90       	pop	r0
     4be:	cf 91       	pop	r28
     4c0:	df 91       	pop	r29
     4c2:	08 95       	ret

000004c4 <out>:

void out(char port, int pin, _Bool value) {
     4c4:	df 93       	push	r29
     4c6:	cf 93       	push	r28
     4c8:	00 d0       	rcall	.+0      	; 0x4ca <out+0x6>
     4ca:	00 d0       	rcall	.+0      	; 0x4cc <out+0x8>
     4cc:	00 d0       	rcall	.+0      	; 0x4ce <out+0xa>
     4ce:	cd b7       	in	r28, 0x3d	; 61
     4d0:	de b7       	in	r29, 0x3e	; 62
     4d2:	89 83       	std	Y+1, r24	; 0x01
     4d4:	7b 83       	std	Y+3, r23	; 0x03
     4d6:	6a 83       	std	Y+2, r22	; 0x02
     4d8:	4c 83       	std	Y+4, r20	; 0x04
    simply pass the Port as either D or B (make sure to enclose it in single
    quotes like so: 'D')
    The pin number you would like to change state of,
    and either a 0 to sink current or 1 to source it on that pin
    */
    switch (port) { //switch determines if which port it is
     4da:	89 81       	ldd	r24, Y+1	; 0x01
     4dc:	28 2f       	mov	r18, r24
     4de:	33 27       	eor	r19, r19
     4e0:	27 fd       	sbrc	r18, 7
     4e2:	30 95       	com	r19
     4e4:	3e 83       	std	Y+6, r19	; 0x06
     4e6:	2d 83       	std	Y+5, r18	; 0x05
     4e8:	8d 81       	ldd	r24, Y+5	; 0x05
     4ea:	9e 81       	ldd	r25, Y+6	; 0x06
     4ec:	82 34       	cpi	r24, 0x42	; 66
     4ee:	91 05       	cpc	r25, r1
     4f0:	e1 f1       	breq	.+120    	; 0x56a <out+0xa6>
     4f2:	2d 81       	ldd	r18, Y+5	; 0x05
     4f4:	3e 81       	ldd	r19, Y+6	; 0x06
     4f6:	24 34       	cpi	r18, 0x44	; 68
     4f8:	31 05       	cpc	r19, r1
     4fa:	09 f0       	breq	.+2      	; 0x4fe <out+0x3a>
     4fc:	6b c0       	rjmp	.+214    	; 0x5d4 <out+0x110>
        case 'D':
            DDRD |= (1<<pin); //change the pin to output
     4fe:	aa e2       	ldi	r26, 0x2A	; 42
     500:	b0 e0       	ldi	r27, 0x00	; 0
     502:	ea e2       	ldi	r30, 0x2A	; 42
     504:	f0 e0       	ldi	r31, 0x00	; 0
     506:	80 81       	ld	r24, Z
     508:	28 2f       	mov	r18, r24
     50a:	81 e0       	ldi	r24, 0x01	; 1
     50c:	90 e0       	ldi	r25, 0x00	; 0
     50e:	0a 80       	ldd	r0, Y+2	; 0x02
     510:	02 c0       	rjmp	.+4      	; 0x516 <out+0x52>
     512:	88 0f       	add	r24, r24
     514:	99 1f       	adc	r25, r25
     516:	0a 94       	dec	r0
     518:	e2 f7       	brpl	.-8      	; 0x512 <out+0x4e>
     51a:	82 2b       	or	r24, r18
     51c:	8c 93       	st	X, r24
            if(value == 1) { //sink or source current
     51e:	8c 81       	ldd	r24, Y+4	; 0x04
     520:	88 23       	and	r24, r24
     522:	89 f0       	breq	.+34     	; 0x546 <out+0x82>
                PORTD |= (1<<pin);
     524:	ab e2       	ldi	r26, 0x2B	; 43
     526:	b0 e0       	ldi	r27, 0x00	; 0
     528:	eb e2       	ldi	r30, 0x2B	; 43
     52a:	f0 e0       	ldi	r31, 0x00	; 0
     52c:	80 81       	ld	r24, Z
     52e:	28 2f       	mov	r18, r24
     530:	81 e0       	ldi	r24, 0x01	; 1
     532:	90 e0       	ldi	r25, 0x00	; 0
     534:	0a 80       	ldd	r0, Y+2	; 0x02
     536:	02 c0       	rjmp	.+4      	; 0x53c <out+0x78>
     538:	88 0f       	add	r24, r24
     53a:	99 1f       	adc	r25, r25
     53c:	0a 94       	dec	r0
     53e:	e2 f7       	brpl	.-8      	; 0x538 <out+0x74>
     540:	82 2b       	or	r24, r18
     542:	8c 93       	st	X, r24
     544:	47 c0       	rjmp	.+142    	; 0x5d4 <out+0x110>
            } else {
                PORTD &= ~(1<<pin);
     546:	ab e2       	ldi	r26, 0x2B	; 43
     548:	b0 e0       	ldi	r27, 0x00	; 0
     54a:	eb e2       	ldi	r30, 0x2B	; 43
     54c:	f0 e0       	ldi	r31, 0x00	; 0
     54e:	80 81       	ld	r24, Z
     550:	28 2f       	mov	r18, r24
     552:	81 e0       	ldi	r24, 0x01	; 1
     554:	90 e0       	ldi	r25, 0x00	; 0
     556:	0a 80       	ldd	r0, Y+2	; 0x02
     558:	02 c0       	rjmp	.+4      	; 0x55e <out+0x9a>
     55a:	88 0f       	add	r24, r24
     55c:	99 1f       	adc	r25, r25
     55e:	0a 94       	dec	r0
     560:	e2 f7       	brpl	.-8      	; 0x55a <out+0x96>
     562:	80 95       	com	r24
     564:	82 23       	and	r24, r18
     566:	8c 93       	st	X, r24
     568:	35 c0       	rjmp	.+106    	; 0x5d4 <out+0x110>
            }
            break;
        case 'B':
            DDRB |= (1<<pin); //change pin to output
     56a:	a4 e2       	ldi	r26, 0x24	; 36
     56c:	b0 e0       	ldi	r27, 0x00	; 0
     56e:	e4 e2       	ldi	r30, 0x24	; 36
     570:	f0 e0       	ldi	r31, 0x00	; 0
     572:	80 81       	ld	r24, Z
     574:	28 2f       	mov	r18, r24
     576:	81 e0       	ldi	r24, 0x01	; 1
     578:	90 e0       	ldi	r25, 0x00	; 0
     57a:	0a 80       	ldd	r0, Y+2	; 0x02
     57c:	02 c0       	rjmp	.+4      	; 0x582 <out+0xbe>
     57e:	88 0f       	add	r24, r24
     580:	99 1f       	adc	r25, r25
     582:	0a 94       	dec	r0
     584:	e2 f7       	brpl	.-8      	; 0x57e <out+0xba>
     586:	82 2b       	or	r24, r18
     588:	8c 93       	st	X, r24
            if(value == 1) { //sink or source current
     58a:	8c 81       	ldd	r24, Y+4	; 0x04
     58c:	88 23       	and	r24, r24
     58e:	89 f0       	breq	.+34     	; 0x5b2 <out+0xee>
                PORTB |= (1<<pin);
     590:	a5 e2       	ldi	r26, 0x25	; 37
     592:	b0 e0       	ldi	r27, 0x00	; 0
     594:	e5 e2       	ldi	r30, 0x25	; 37
     596:	f0 e0       	ldi	r31, 0x00	; 0
     598:	80 81       	ld	r24, Z
     59a:	28 2f       	mov	r18, r24
     59c:	81 e0       	ldi	r24, 0x01	; 1
     59e:	90 e0       	ldi	r25, 0x00	; 0
     5a0:	0a 80       	ldd	r0, Y+2	; 0x02
     5a2:	02 c0       	rjmp	.+4      	; 0x5a8 <out+0xe4>
     5a4:	88 0f       	add	r24, r24
     5a6:	99 1f       	adc	r25, r25
     5a8:	0a 94       	dec	r0
     5aa:	e2 f7       	brpl	.-8      	; 0x5a4 <out+0xe0>
     5ac:	82 2b       	or	r24, r18
     5ae:	8c 93       	st	X, r24
     5b0:	11 c0       	rjmp	.+34     	; 0x5d4 <out+0x110>
            } else {
                PORTB &= ~(1<<pin);
     5b2:	a5 e2       	ldi	r26, 0x25	; 37
     5b4:	b0 e0       	ldi	r27, 0x00	; 0
     5b6:	e5 e2       	ldi	r30, 0x25	; 37
     5b8:	f0 e0       	ldi	r31, 0x00	; 0
     5ba:	80 81       	ld	r24, Z
     5bc:	28 2f       	mov	r18, r24
     5be:	81 e0       	ldi	r24, 0x01	; 1
     5c0:	90 e0       	ldi	r25, 0x00	; 0
     5c2:	0a 80       	ldd	r0, Y+2	; 0x02
     5c4:	02 c0       	rjmp	.+4      	; 0x5ca <out+0x106>
     5c6:	88 0f       	add	r24, r24
     5c8:	99 1f       	adc	r25, r25
     5ca:	0a 94       	dec	r0
     5cc:	e2 f7       	brpl	.-8      	; 0x5c6 <out+0x102>
     5ce:	80 95       	com	r24
     5d0:	82 23       	and	r24, r18
     5d2:	8c 93       	st	X, r24
            }
            break;
    }
}
     5d4:	26 96       	adiw	r28, 0x06	; 6
     5d6:	0f b6       	in	r0, 0x3f	; 63
     5d8:	f8 94       	cli
     5da:	de bf       	out	0x3e, r29	; 62
     5dc:	0f be       	out	0x3f, r0	; 63
     5de:	cd bf       	out	0x3d, r28	; 61
     5e0:	cf 91       	pop	r28
     5e2:	df 91       	pop	r29
     5e4:	08 95       	ret

000005e6 <setup_timer0>:

void setup_timer0(void) {
     5e6:	df 93       	push	r29
     5e8:	cf 93       	push	r28
     5ea:	cd b7       	in	r28, 0x3d	; 61
     5ec:	de b7       	in	r29, 0x3e	; 62
    TCNT0 = 0; //set the inital timer value to 0
     5ee:	e6 e4       	ldi	r30, 0x46	; 70
     5f0:	f0 e0       	ldi	r31, 0x00	; 0
     5f2:	10 82       	st	Z, r1
    TCCR0B |= (1<<CS01); //set the clock prescaler to clock/8 or 2mHz
     5f4:	a5 e4       	ldi	r26, 0x45	; 69
     5f6:	b0 e0       	ldi	r27, 0x00	; 0
     5f8:	e5 e4       	ldi	r30, 0x45	; 69
     5fa:	f0 e0       	ldi	r31, 0x00	; 0
     5fc:	80 81       	ld	r24, Z
     5fe:	82 60       	ori	r24, 0x02	; 2
     600:	8c 93       	st	X, r24
    TIMSK0 |= (1<<TOIE0); //start the timer with the interrupt overflow turned on
     602:	ae e6       	ldi	r26, 0x6E	; 110
     604:	b0 e0       	ldi	r27, 0x00	; 0
     606:	ee e6       	ldi	r30, 0x6E	; 110
     608:	f0 e0       	ldi	r31, 0x00	; 0
     60a:	80 81       	ld	r24, Z
     60c:	81 60       	ori	r24, 0x01	; 1
     60e:	8c 93       	st	X, r24
}
     610:	cf 91       	pop	r28
     612:	df 91       	pop	r29
     614:	08 95       	ret

00000616 <check_buttons>:

void check_buttons(void) {
     616:	df 93       	push	r29
     618:	cf 93       	push	r28
     61a:	cd b7       	in	r28, 0x3d	; 61
     61c:	de b7       	in	r29, 0x3e	; 62
    Timer0 ISR which keeps track of how stable the button is. If the button is stable
    then this bit of code will change it's matching variable which indicates the state
    for the rest of the code. If the button isn't stable then it doesn't do anything.
    */
    //button one
    if (count[0] > 10) { //if the buttons stable, set the array for button 1 as stable
     61e:	80 91 d9 03 	lds	r24, 0x03D9
     622:	8b 30       	cpi	r24, 0x0B	; 11
     624:	18 f0       	brcs	.+6      	; 0x62c <check_buttons+0x16>
        //and reset the counter if the buttons been released
        /*if ((PIND & button_one) == 0) {
            count[0] = 0;
        }*/
        button[0] = 1;
     626:	81 e0       	ldi	r24, 0x01	; 1
     628:	80 93 15 01 	sts	0x0115, r24
    }
    if ((PIND & button_one) == 0) {
     62c:	e9 e2       	ldi	r30, 0x29	; 41
     62e:	f0 e0       	ldi	r31, 0x00	; 0
     630:	80 81       	ld	r24, Z
     632:	88 2f       	mov	r24, r24
     634:	90 e0       	ldi	r25, 0x00	; 0
     636:	88 70       	andi	r24, 0x08	; 8
     638:	90 70       	andi	r25, 0x00	; 0
     63a:	00 97       	sbiw	r24, 0x00	; 0
     63c:	11 f4       	brne	.+4      	; 0x642 <check_buttons+0x2c>
        button[0] = 0;
     63e:	10 92 15 01 	sts	0x0115, r1
    }

    //button one
    if (count[1] > 10) { //if the buttons stable, set the array for button 1 as stable
     642:	80 91 da 03 	lds	r24, 0x03DA
     646:	8b 30       	cpi	r24, 0x0B	; 11
     648:	18 f0       	brcs	.+6      	; 0x650 <check_buttons+0x3a>
        //and reset the counter if the buttons been released
        /*if ((PIND & button_one) == 0) {
            count[0] = 0;
        }*/
        button[1] = 1;
     64a:	81 e0       	ldi	r24, 0x01	; 1
     64c:	80 93 16 01 	sts	0x0116, r24
    }
    if ((PIND & button_two) == 0) {
     650:	e9 e2       	ldi	r30, 0x29	; 41
     652:	f0 e0       	ldi	r31, 0x00	; 0
     654:	80 81       	ld	r24, Z
     656:	88 2f       	mov	r24, r24
     658:	90 e0       	ldi	r25, 0x00	; 0
     65a:	80 71       	andi	r24, 0x10	; 16
     65c:	90 70       	andi	r25, 0x00	; 0
     65e:	00 97       	sbiw	r24, 0x00	; 0
     660:	11 f4       	brne	.+4      	; 0x666 <check_buttons+0x50>
        button[1] = 0;
     662:	10 92 16 01 	sts	0x0116, r1
    }
}
     666:	cf 91       	pop	r28
     668:	df 91       	pop	r29
     66a:	08 95       	ret

0000066c <buttons>:

void buttons(void) {
     66c:	df 93       	push	r29
     66e:	cf 93       	push	r28
     670:	cd b7       	in	r28, 0x3d	; 61
     672:	de b7       	in	r29, 0x3e	; 62
    /*
    This little function holds all of the handlers for the buttons, ie: what to do when
    a button has been pressed.
    */
    if (button[0] == 1) { //If the first button is pulled high then
     674:	80 91 15 01 	lds	r24, 0x0115
     678:	81 30       	cpi	r24, 0x01	; 1
     67a:	01 f5       	brne	.+64     	; 0x6bc <buttons+0x50>
        for (i_one = 0; i_one < 2; i_one++) {
     67c:	10 92 f9 03 	sts	0x03F9, r1
     680:	0a c0       	rjmp	.+20     	; 0x696 <buttons+0x2a>
            uart_sendint(ultrasound_filter(1));
     682:	81 e0       	ldi	r24, 0x01	; 1
     684:	0e 94 c4 07 	call	0xf88	; 0xf88 <ultrasound_filter>
     688:	0e 94 1f 09 	call	0x123e	; 0x123e <uart_sendint>
    /*
    This little function holds all of the handlers for the buttons, ie: what to do when
    a button has been pressed.
    */
    if (button[0] == 1) { //If the first button is pulled high then
        for (i_one = 0; i_one < 2; i_one++) {
     68c:	80 91 f9 03 	lds	r24, 0x03F9
     690:	8f 5f       	subi	r24, 0xFF	; 255
     692:	80 93 f9 03 	sts	0x03F9, r24
     696:	80 91 f9 03 	lds	r24, 0x03F9
     69a:	82 30       	cpi	r24, 0x02	; 2
     69c:	90 f3       	brcs	.-28     	; 0x682 <buttons+0x16>
            uart_sendint(ultrasound_filter(1));
        }
        do {
            uart_sendint(ultrasound_filter(1));
     69e:	81 e0       	ldi	r24, 0x01	; 1
     6a0:	0e 94 c4 07 	call	0xf88	; 0xf88 <ultrasound_filter>
     6a4:	0e 94 1f 09 	call	0x123e	; 0x123e <uart_sendint>
        } while (i_one == 0);
     6a8:	80 91 f9 03 	lds	r24, 0x03F9
     6ac:	88 23       	and	r24, r24
     6ae:	b9 f3       	breq	.-18     	; 0x69e <buttons+0x32>
        i_one++;
     6b0:	80 91 f9 03 	lds	r24, 0x03F9
     6b4:	8f 5f       	subi	r24, 0xFF	; 255
     6b6:	80 93 f9 03 	sts	0x03F9, r24
     6ba:	02 c0       	rjmp	.+4      	; 0x6c0 <buttons+0x54>
    } else {
        i_one = 0;
     6bc:	10 92 f9 03 	sts	0x03F9, r1
    }
}
     6c0:	cf 91       	pop	r28
     6c2:	df 91       	pop	r29
     6c4:	08 95       	ret

000006c6 <__vector_16>:

ISR(TIMER0_OVF_vect) {
     6c6:	1f 92       	push	r1
     6c8:	0f 92       	push	r0
     6ca:	0f b6       	in	r0, 0x3f	; 63
     6cc:	0f 92       	push	r0
     6ce:	11 24       	eor	r1, r1
     6d0:	8f 93       	push	r24
     6d2:	9f 93       	push	r25
     6d4:	ef 93       	push	r30
     6d6:	ff 93       	push	r31
     6d8:	df 93       	push	r29
     6da:	cf 93       	push	r28
     6dc:	cd b7       	in	r28, 0x3d	; 61
     6de:	de b7       	in	r29, 0x3e	; 62
    for each button which will increase if the button is stable in it's state,
    everytime this is ran, or will reset the timer if the button isn't stable, ie
    bouncing, which is what we don't want.
    */
    //figure out what pins been changed, and take the correct action
    if ((PIND & button_one)) {
     6e0:	e9 e2       	ldi	r30, 0x29	; 41
     6e2:	f0 e0       	ldi	r31, 0x00	; 0
     6e4:	80 81       	ld	r24, Z
     6e6:	88 2f       	mov	r24, r24
     6e8:	90 e0       	ldi	r25, 0x00	; 0
     6ea:	88 70       	andi	r24, 0x08	; 8
     6ec:	90 70       	andi	r25, 0x00	; 0
     6ee:	00 97       	sbiw	r24, 0x00	; 0
     6f0:	31 f0       	breq	.+12     	; 0x6fe <__vector_16+0x38>
        //simply increases or resets a counter, the main code then looks at the counter
        //and determines if the buttons been pressed, or held down
        count[0]++; //if buttton_ones been pressed, increase the count, as long as
     6f2:	80 91 d9 03 	lds	r24, 0x03D9
     6f6:	8f 5f       	subi	r24, 0xFF	; 255
     6f8:	80 93 d9 03 	sts	0x03D9, r24
     6fc:	02 c0       	rjmp	.+4      	; 0x702 <__vector_16+0x3c>
        //the button continues to stay the same
    } else {
        count[0] = 0;
     6fe:	10 92 d9 03 	sts	0x03D9, r1
        //if the button changes state, reset the count
    }
    if ((PIND & button_two)) {
     702:	e9 e2       	ldi	r30, 0x29	; 41
     704:	f0 e0       	ldi	r31, 0x00	; 0
     706:	80 81       	ld	r24, Z
     708:	88 2f       	mov	r24, r24
     70a:	90 e0       	ldi	r25, 0x00	; 0
     70c:	80 71       	andi	r24, 0x10	; 16
     70e:	90 70       	andi	r25, 0x00	; 0
     710:	00 97       	sbiw	r24, 0x00	; 0
     712:	31 f0       	breq	.+12     	; 0x720 <__vector_16+0x5a>
        //simply increases or resets a counter, the main code then looks at the counter
        //and determines if the buttons been pressed, or held down
        count[1]++; //if buttton_ones been pressed, increase the count, as long as
     714:	80 91 da 03 	lds	r24, 0x03DA
     718:	8f 5f       	subi	r24, 0xFF	; 255
     71a:	80 93 da 03 	sts	0x03DA, r24
     71e:	02 c0       	rjmp	.+4      	; 0x724 <__vector_16+0x5e>
        //the button continues to stay the same
    } else {
        count[1] = 0;
     720:	10 92 da 03 	sts	0x03DA, r1
        //if the button changes state, reset the count
    }
}
     724:	cf 91       	pop	r28
     726:	df 91       	pop	r29
     728:	ff 91       	pop	r31
     72a:	ef 91       	pop	r30
     72c:	9f 91       	pop	r25
     72e:	8f 91       	pop	r24
     730:	0f 90       	pop	r0
     732:	0f be       	out	0x3f, r0	; 63
     734:	0f 90       	pop	r0
     736:	1f 90       	pop	r1
     738:	18 95       	reti

0000073a <twi_start>:
freenode/#linuxandsci - JoshAshby
*/
//-------------------------------------------
#include "global.h"

void twi_start(void) { //set up the clock speed for the I2C/TWI
     73a:	df 93       	push	r29
     73c:	cf 93       	push	r28
     73e:	cd b7       	in	r28, 0x3d	; 61
     740:	de b7       	in	r29, 0x3e	; 62
    TWSR = 0x00;
     742:	e9 eb       	ldi	r30, 0xB9	; 185
     744:	f0 e0       	ldi	r31, 0x00	; 0
     746:	10 82       	st	Z, r1
    TWBR = (F_CPU / 100000UL - 16) / 2;
     748:	e8 eb       	ldi	r30, 0xB8	; 184
     74a:	f0 e0       	ldi	r31, 0x00	; 0
     74c:	88 e4       	ldi	r24, 0x48	; 72
     74e:	80 83       	st	Z, r24
}
     750:	cf 91       	pop	r28
     752:	df 91       	pop	r29
     754:	08 95       	ret

00000756 <twi_tran>:

//various different things to help condense code
unsigned char twi_tran(unsigned char type) {
     756:	df 93       	push	r29
     758:	cf 93       	push	r28
     75a:	00 d0       	rcall	.+0      	; 0x75c <twi_tran+0x6>
     75c:	00 d0       	rcall	.+0      	; 0x75e <twi_tran+0x8>
     75e:	cd b7       	in	r28, 0x3d	; 61
     760:	de b7       	in	r29, 0x3e	; 62
     762:	89 83       	std	Y+1, r24	; 0x01
  switch(type) {
     764:	89 81       	ldd	r24, Y+1	; 0x01
     766:	28 2f       	mov	r18, r24
     768:	30 e0       	ldi	r19, 0x00	; 0
     76a:	3c 83       	std	Y+4, r19	; 0x04
     76c:	2b 83       	std	Y+3, r18	; 0x03
     76e:	8b 81       	ldd	r24, Y+3	; 0x03
     770:	9c 81       	ldd	r25, Y+4	; 0x04
     772:	81 30       	cpi	r24, 0x01	; 1
     774:	91 05       	cpc	r25, r1
     776:	71 f0       	breq	.+28     	; 0x794 <twi_tran+0x3e>
     778:	2b 81       	ldd	r18, Y+3	; 0x03
     77a:	3c 81       	ldd	r19, Y+4	; 0x04
     77c:	22 30       	cpi	r18, 0x02	; 2
     77e:	31 05       	cpc	r19, r1
     780:	71 f0       	breq	.+28     	; 0x79e <twi_tran+0x48>
     782:	8b 81       	ldd	r24, Y+3	; 0x03
     784:	9c 81       	ldd	r25, Y+4	; 0x04
     786:	00 97       	sbiw	r24, 0x00	; 0
     788:	81 f4       	brne	.+32     	; 0x7aa <twi_tran+0x54>
     case TWI_START: //Start Condition
       TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN);
     78a:	ec eb       	ldi	r30, 0xBC	; 188
     78c:	f0 e0       	ldi	r31, 0x00	; 0
     78e:	84 ea       	ldi	r24, 0xA4	; 164
     790:	80 83       	st	Z, r24
     792:	0b c0       	rjmp	.+22     	; 0x7aa <twi_tran+0x54>
       break;
     case TWI_DATA: //Data
       TWCR = (1 << TWINT) | (1 << TWEN);
     794:	ec eb       	ldi	r30, 0xBC	; 188
     796:	f0 e0       	ldi	r31, 0x00	; 0
     798:	84 e8       	ldi	r24, 0x84	; 132
     79a:	80 83       	st	Z, r24
     79c:	06 c0       	rjmp	.+12     	; 0x7aa <twi_tran+0x54>
       break;
     case TWI_STOP: //Stop Condition
       TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);
     79e:	ec eb       	ldi	r30, 0xBC	; 188
     7a0:	f0 e0       	ldi	r31, 0x00	; 0
     7a2:	84 e9       	ldi	r24, 0x94	; 148
     7a4:	80 83       	st	Z, r24
       return 0;
     7a6:	1a 82       	std	Y+2, r1	; 0x02
     7a8:	0b c0       	rjmp	.+22     	; 0x7c0 <twi_tran+0x6a>
  }
  while (!(TWCR & (1 << TWINT))); // Wait for TWINT flag set in TWCR Register
     7aa:	ec eb       	ldi	r30, 0xBC	; 188
     7ac:	f0 e0       	ldi	r31, 0x00	; 0
     7ae:	80 81       	ld	r24, Z
     7b0:	88 23       	and	r24, r24
     7b2:	dc f7       	brge	.-10     	; 0x7aa <twi_tran+0x54>
  return (TWSR & 0xF8); // Return TWI Status Register, mask the prescaler bits (TWPS1,TWPS0)
     7b4:	e9 eb       	ldi	r30, 0xB9	; 185
     7b6:	f0 e0       	ldi	r31, 0x00	; 0
     7b8:	80 81       	ld	r24, Z
     7ba:	98 2f       	mov	r25, r24
     7bc:	98 7f       	andi	r25, 0xF8	; 248
     7be:	9a 83       	std	Y+2, r25	; 0x02
     7c0:	8a 81       	ldd	r24, Y+2	; 0x02
}
     7c2:	0f 90       	pop	r0
     7c4:	0f 90       	pop	r0
     7c6:	0f 90       	pop	r0
     7c8:	0f 90       	pop	r0
     7ca:	cf 91       	pop	r28
     7cc:	df 91       	pop	r29
     7ce:	08 95       	ret

000007d0 <twi_mcp_dac>:
First to write to the dac only we must specify this in the POD byte
for DAC only we send 0x40 which is 0b01000000 because we don't want
any of the Power Down stuff and we only want DAC which means C2, C1, C0,
should be 0, 1, 0 respectably. for writing to the DAC and the EEPROM
they would be 0, 1, 1 and the last byte on the address should be 1 */
int twi_mcp_dac(unsigned int twi_address, uint16_t data, _Bool type) {
     7d0:	df 93       	push	r29
     7d2:	cf 93       	push	r28
     7d4:	cd b7       	in	r28, 0x3d	; 61
     7d6:	de b7       	in	r29, 0x3e	; 62
     7d8:	2b 97       	sbiw	r28, 0x0b	; 11
     7da:	0f b6       	in	r0, 0x3f	; 63
     7dc:	f8 94       	cli
     7de:	de bf       	out	0x3e, r29	; 62
     7e0:	0f be       	out	0x3f, r0	; 63
     7e2:	cd bf       	out	0x3d, r28	; 61
     7e4:	9d 83       	std	Y+5, r25	; 0x05
     7e6:	8c 83       	std	Y+4, r24	; 0x04
     7e8:	7f 83       	std	Y+7, r23	; 0x07
     7ea:	6e 83       	std	Y+6, r22	; 0x06
     7ec:	48 87       	std	Y+8, r20	; 0x08
    /*
    Pass the address, the 16 bit long data for the DAC/EEPROM
    and either 1 for POD which will write to the EEPROM or 0 to just write to the DAC
    */
    unsigned char n = 0;
     7ee:	1b 82       	std	Y+3, r1	; 0x03
    unsigned char twi_status;
    char r_val = -1;
     7f0:	8f ef       	ldi	r24, 0xFF	; 255
     7f2:	89 83       	std	Y+1, r24	; 0x01
    twi_retry:
        if (n++ >= MAX_TRIES) return r_val;
     7f4:	1b 86       	std	Y+11, r1	; 0x0b
     7f6:	8b 81       	ldd	r24, Y+3	; 0x03
     7f8:	82 33       	cpi	r24, 0x32	; 50
     7fa:	10 f0       	brcs	.+4      	; 0x800 <twi_mcp_dac+0x30>
     7fc:	21 e0       	ldi	r18, 0x01	; 1
     7fe:	2b 87       	std	Y+11, r18	; 0x0b
     800:	8b 81       	ldd	r24, Y+3	; 0x03
     802:	8f 5f       	subi	r24, 0xFF	; 255
     804:	8b 83       	std	Y+3, r24	; 0x03
     806:	3b 85       	ldd	r19, Y+11	; 0x0b
     808:	33 23       	and	r19, r19
     80a:	41 f0       	breq	.+16     	; 0x81c <twi_mcp_dac+0x4c>
     80c:	89 81       	ldd	r24, Y+1	; 0x01
     80e:	28 2f       	mov	r18, r24
     810:	33 27       	eor	r19, r19
     812:	27 fd       	sbrc	r18, 7
     814:	30 95       	com	r19
     816:	3a 87       	std	Y+10, r19	; 0x0a
     818:	29 87       	std	Y+9, r18	; 0x09
     81a:	86 c0       	rjmp	.+268    	; 0x928 <__stack+0x29>

        //first we must try to start the TWI interface
        twi_status=twi_tran(TWI_START);  //Start Condition
     81c:	80 e0       	ldi	r24, 0x00	; 0
     81e:	0e 94 ab 03 	call	0x756	; 0x756 <twi_tran>
     822:	8a 83       	std	Y+2, r24	; 0x02
        if (twi_status == TW_MT_ARB_LOST) goto twi_retry;  //TWI Status
     824:	8a 81       	ldd	r24, Y+2	; 0x02
     826:	88 33       	cpi	r24, 0x38	; 56
     828:	29 f3       	breq	.-54     	; 0x7f4 <twi_mcp_dac+0x24>
        if ((twi_status != TW_START) && (twi_status != TW_REP_START)) goto twi_quit;
     82a:	8a 81       	ldd	r24, Y+2	; 0x02
     82c:	88 30       	cpi	r24, 0x08	; 8
     82e:	21 f0       	breq	.+8      	; 0x838 <twi_mcp_dac+0x68>
     830:	8a 81       	ldd	r24, Y+2	; 0x02
     832:	80 31       	cpi	r24, 0x10	; 16
     834:	09 f0       	breq	.+2      	; 0x838 <twi_mcp_dac+0x68>
     836:	6d c0       	rjmp	.+218    	; 0x912 <__stack+0x13>

        //next we send the slave address, which in this case has 0 to only write to the dac
        TWDR = twi_address | 0;  //Send slave address
     838:	eb eb       	ldi	r30, 0xBB	; 187
     83a:	f0 e0       	ldi	r31, 0x00	; 0
     83c:	8c 81       	ldd	r24, Y+4	; 0x04
     83e:	80 83       	st	Z, r24
        twi_status=twi_tran(TWI_DATA);  //Transmit
     840:	81 e0       	ldi	r24, 0x01	; 1
     842:	0e 94 ab 03 	call	0x756	; 0x756 <twi_tran>
     846:	8a 83       	std	Y+2, r24	; 0x02
        if ((twi_status == TW_MT_SLA_NACK) || (twi_status == TW_MT_ARB_LOST)) goto twi_retry;  //TWSR status
     848:	8a 81       	ldd	r24, Y+2	; 0x02
     84a:	80 32       	cpi	r24, 0x20	; 32
     84c:	99 f2       	breq	.-90     	; 0x7f4 <twi_mcp_dac+0x24>
     84e:	8a 81       	ldd	r24, Y+2	; 0x02
     850:	88 33       	cpi	r24, 0x38	; 56
     852:	81 f2       	breq	.-96     	; 0x7f4 <twi_mcp_dac+0x24>
        if (twi_status != TW_MT_SLA_ACK) goto twi_quit;
     854:	8a 81       	ldd	r24, Y+2	; 0x02
     856:	88 31       	cpi	r24, 0x18	; 24
     858:	09 f0       	breq	.+2      	; 0x85c <twi_mcp_dac+0x8c>
     85a:	5b c0       	rjmp	.+182    	; 0x912 <__stack+0x13>

        //next we send the POD byte which tells the MCP we will only be writing to the DAC and not EEPROM and not in fast mode either
        if (type) {
     85c:	88 85       	ldd	r24, Y+8	; 0x08
     85e:	88 23       	and	r24, r24
     860:	29 f0       	breq	.+10     	; 0x86c <twi_mcp_dac+0x9c>
            TWDR = 0x60;  //Send the POD data
     862:	eb eb       	ldi	r30, 0xBB	; 187
     864:	f0 e0       	ldi	r31, 0x00	; 0
     866:	80 e6       	ldi	r24, 0x60	; 96
     868:	80 83       	st	Z, r24
     86a:	04 c0       	rjmp	.+8      	; 0x874 <twi_mcp_dac+0xa4>
        } else {
            TWDR = 0x40;
     86c:	eb eb       	ldi	r30, 0xBB	; 187
     86e:	f0 e0       	ldi	r31, 0x00	; 0
     870:	80 e4       	ldi	r24, 0x40	; 64
     872:	80 83       	st	Z, r24
        }
        twi_status=twi_tran(TWI_DATA);  //Transmit
     874:	81 e0       	ldi	r24, 0x01	; 1
     876:	0e 94 ab 03 	call	0x756	; 0x756 <twi_tran>
     87a:	8a 83       	std	Y+2, r24	; 0x02
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //status
     87c:	8a 81       	ldd	r24, Y+2	; 0x02
     87e:	88 32       	cpi	r24, 0x28	; 40
     880:	09 f0       	breq	.+2      	; 0x884 <twi_mcp_dac+0xb4>
     882:	47 c0       	rjmp	.+142    	; 0x912 <__stack+0x13>

        //next we send the 12bit data in two transfers to get it all across
        TWDR = data;  //Send the first byte of data
     884:	eb eb       	ldi	r30, 0xBB	; 187
     886:	f0 e0       	ldi	r31, 0x00	; 0
     888:	8e 81       	ldd	r24, Y+6	; 0x06
     88a:	80 83       	st	Z, r24
        twi_status=twi_tran(TWI_DATA);  //Transmit
     88c:	81 e0       	ldi	r24, 0x01	; 1
     88e:	0e 94 ab 03 	call	0x756	; 0x756 <twi_tran>
     892:	8a 83       	std	Y+2, r24	; 0x02
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     894:	8a 81       	ldd	r24, Y+2	; 0x02
     896:	88 32       	cpi	r24, 0x28	; 40
     898:	e1 f5       	brne	.+120    	; 0x912 <__stack+0x13>

        //and second part
        TWDR = (data >> 8);  //Send second byte of data
     89a:	eb eb       	ldi	r30, 0xBB	; 187
     89c:	f0 e0       	ldi	r31, 0x00	; 0
     89e:	8e 81       	ldd	r24, Y+6	; 0x06
     8a0:	9f 81       	ldd	r25, Y+7	; 0x07
     8a2:	89 2f       	mov	r24, r25
     8a4:	99 27       	eor	r25, r25
     8a6:	80 83       	st	Z, r24
        twi_status=twi_tran(TWI_DATA);  //Transmit
     8a8:	81 e0       	ldi	r24, 0x01	; 1
     8aa:	0e 94 ab 03 	call	0x756	; 0x756 <twi_tran>
     8ae:	8a 83       	std	Y+2, r24	; 0x02
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     8b0:	8a 81       	ldd	r24, Y+2	; 0x02
     8b2:	88 32       	cpi	r24, 0x28	; 40
     8b4:	71 f5       	brne	.+92     	; 0x912 <__stack+0x13>

        //finally we have to repeat the whole thing over to make sure it got it all according to the datasheet so we do this all again
        if (type) {
     8b6:	88 85       	ldd	r24, Y+8	; 0x08
     8b8:	88 23       	and	r24, r24
     8ba:	29 f0       	breq	.+10     	; 0x8c6 <twi_mcp_dac+0xf6>
            TWDR = 0x60;  //Send the POD data
     8bc:	eb eb       	ldi	r30, 0xBB	; 187
     8be:	f0 e0       	ldi	r31, 0x00	; 0
     8c0:	80 e6       	ldi	r24, 0x60	; 96
     8c2:	80 83       	st	Z, r24
     8c4:	04 c0       	rjmp	.+8      	; 0x8ce <twi_mcp_dac+0xfe>
        } else {
            TWDR = 0x40;
     8c6:	eb eb       	ldi	r30, 0xBB	; 187
     8c8:	f0 e0       	ldi	r31, 0x00	; 0
     8ca:	80 e4       	ldi	r24, 0x40	; 64
     8cc:	80 83       	st	Z, r24
        }
        twi_status=twi_tran(TWI_DATA);  //Transmit
     8ce:	81 e0       	ldi	r24, 0x01	; 1
     8d0:	0e 94 ab 03 	call	0x756	; 0x756 <twi_tran>
     8d4:	8a 83       	std	Y+2, r24	; 0x02
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     8d6:	8a 81       	ldd	r24, Y+2	; 0x02
     8d8:	88 32       	cpi	r24, 0x28	; 40
     8da:	d9 f4       	brne	.+54     	; 0x912 <__stack+0x13>
        TWDR = data;  //Send the first bytes of Data
     8dc:	eb eb       	ldi	r30, 0xBB	; 187
     8de:	f0 e0       	ldi	r31, 0x00	; 0
     8e0:	8e 81       	ldd	r24, Y+6	; 0x06
     8e2:	80 83       	st	Z, r24
        twi_status=twi_tran(TWI_DATA);  //Transmit
     8e4:	81 e0       	ldi	r24, 0x01	; 1
     8e6:	0e 94 ab 03 	call	0x756	; 0x756 <twi_tran>
     8ea:	8a 83       	std	Y+2, r24	; 0x02
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     8ec:	8a 81       	ldd	r24, Y+2	; 0x02
     8ee:	88 32       	cpi	r24, 0x28	; 40
     8f0:	81 f4       	brne	.+32     	; 0x912 <__stack+0x13>
        TWDR = (data >> 8);  //Send second byte of data
     8f2:	eb eb       	ldi	r30, 0xBB	; 187
     8f4:	f0 e0       	ldi	r31, 0x00	; 0
     8f6:	8e 81       	ldd	r24, Y+6	; 0x06
     8f8:	9f 81       	ldd	r25, Y+7	; 0x07
     8fa:	89 2f       	mov	r24, r25
     8fc:	99 27       	eor	r25, r25
     8fe:	80 83       	st	Z, r24
        twi_status=twi_tran(TWI_DATA);  //Transmit
     900:	81 e0       	ldi	r24, 0x01	; 1
     902:	0e 94 ab 03 	call	0x756	; 0x756 <twi_tran>
     906:	8a 83       	std	Y+2, r24	; 0x02
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     908:	8a 81       	ldd	r24, Y+2	; 0x02
     90a:	88 32       	cpi	r24, 0x28	; 40
     90c:	11 f4       	brne	.+4      	; 0x912 <__stack+0x13>
        r_val=1;
     90e:	81 e0       	ldi	r24, 0x01	; 1
     910:	89 83       	std	Y+1, r24	; 0x01
    twi_quit:
        //and finally stop
        twi_status=twi_tran(TWI_STOP);  //Transmit
     912:	82 e0       	ldi	r24, 0x02	; 2
     914:	0e 94 ab 03 	call	0x756	; 0x756 <twi_tran>
     918:	8a 83       	std	Y+2, r24	; 0x02
        return r_val;
     91a:	89 81       	ldd	r24, Y+1	; 0x01
     91c:	28 2f       	mov	r18, r24
     91e:	33 27       	eor	r19, r19
     920:	27 fd       	sbrc	r18, 7
     922:	30 95       	com	r19
     924:	3a 87       	std	Y+10, r19	; 0x0a
     926:	29 87       	std	Y+9, r18	; 0x09
     928:	89 85       	ldd	r24, Y+9	; 0x09
     92a:	9a 85       	ldd	r25, Y+10	; 0x0a
}
     92c:	2b 96       	adiw	r28, 0x0b	; 11
     92e:	0f b6       	in	r0, 0x3f	; 63
     930:	f8 94       	cli
     932:	de bf       	out	0x3e, r29	; 62
     934:	0f be       	out	0x3f, r0	; 63
     936:	cd bf       	out	0x3d, r28	; 61
     938:	cf 91       	pop	r28
     93a:	df 91       	pop	r29
     93c:	08 95       	ret

0000093e <twi_mcp_read>:

uint16_t twi_mcp_read(unsigned int twi_address) {
     93e:	df 93       	push	r29
     940:	cf 93       	push	r28
     942:	cd b7       	in	r28, 0x3d	; 61
     944:	de b7       	in	r29, 0x3e	; 62
     946:	2d 97       	sbiw	r28, 0x0d	; 13
     948:	0f b6       	in	r0, 0x3f	; 63
     94a:	f8 94       	cli
     94c:	de bf       	out	0x3e, r29	; 62
     94e:	0f be       	out	0x3f, r0	; 63
     950:	cd bf       	out	0x3d, r28	; 61
     952:	9a 87       	std	Y+10, r25	; 0x0a
     954:	89 87       	std	Y+9, r24	; 0x09
    /*
    Reads the data stored in the EEPROM and returns it as 16bit long data
    */
    unsigned char n = 0;
     956:	18 86       	std	Y+8, r1	; 0x08
    unsigned char twi_status;
    char r_val = -1;
     958:	8f ef       	ldi	r24, 0xFF	; 255
     95a:	8e 83       	std	Y+6, r24	; 0x06
    uint8_t set, first, second, all_first, all_second;
    twi_retry:
        if (n++ >= MAX_TRIES) return r_val;
     95c:	1d 86       	std	Y+13, r1	; 0x0d
     95e:	88 85       	ldd	r24, Y+8	; 0x08
     960:	82 33       	cpi	r24, 0x32	; 50
     962:	10 f0       	brcs	.+4      	; 0x968 <twi_mcp_read+0x2a>
     964:	21 e0       	ldi	r18, 0x01	; 1
     966:	2d 87       	std	Y+13, r18	; 0x0d
     968:	88 85       	ldd	r24, Y+8	; 0x08
     96a:	8f 5f       	subi	r24, 0xFF	; 255
     96c:	88 87       	std	Y+8, r24	; 0x08
     96e:	3d 85       	ldd	r19, Y+13	; 0x0d
     970:	33 23       	and	r19, r19
     972:	41 f0       	breq	.+16     	; 0x984 <twi_mcp_read+0x46>
     974:	8e 81       	ldd	r24, Y+6	; 0x06
     976:	28 2f       	mov	r18, r24
     978:	33 27       	eor	r19, r19
     97a:	27 fd       	sbrc	r18, 7
     97c:	30 95       	com	r19
     97e:	3c 87       	std	Y+12, r19	; 0x0c
     980:	2b 87       	std	Y+11, r18	; 0x0b
     982:	66 c0       	rjmp	.+204    	; 0xa50 <twi_mcp_read+0x112>

        //first we must try to start the TWI interface
        twi_status=twi_tran(TWI_START);  //Start Condition
     984:	80 e0       	ldi	r24, 0x00	; 0
     986:	0e 94 ab 03 	call	0x756	; 0x756 <twi_tran>
     98a:	8f 83       	std	Y+7, r24	; 0x07
        if (twi_status == TW_MT_ARB_LOST) goto twi_retry;  //TWI Status
     98c:	8f 81       	ldd	r24, Y+7	; 0x07
     98e:	88 33       	cpi	r24, 0x38	; 56
     990:	29 f3       	breq	.-54     	; 0x95c <twi_mcp_read+0x1e>
        if ((twi_status != TW_START) && (twi_status != TW_REP_START)) goto twi_quit;
     992:	8f 81       	ldd	r24, Y+7	; 0x07
     994:	88 30       	cpi	r24, 0x08	; 8
     996:	21 f0       	breq	.+8      	; 0x9a0 <twi_mcp_read+0x62>
     998:	8f 81       	ldd	r24, Y+7	; 0x07
     99a:	80 31       	cpi	r24, 0x10	; 16
     99c:	09 f0       	breq	.+2      	; 0x9a0 <twi_mcp_read+0x62>
     99e:	4d c0       	rjmp	.+154    	; 0xa3a <twi_mcp_read+0xfc>

        //next we send the slave address, which in this case has 0 to only write to the dac
        TWDR = twi_address | 1;  //Send slave address
     9a0:	eb eb       	ldi	r30, 0xBB	; 187
     9a2:	f0 e0       	ldi	r31, 0x00	; 0
     9a4:	89 85       	ldd	r24, Y+9	; 0x09
     9a6:	81 60       	ori	r24, 0x01	; 1
     9a8:	80 83       	st	Z, r24
        twi_status=twi_tran(TWI_DATA);  //Transmit
     9aa:	81 e0       	ldi	r24, 0x01	; 1
     9ac:	0e 94 ab 03 	call	0x756	; 0x756 <twi_tran>
     9b0:	8f 83       	std	Y+7, r24	; 0x07
        if ((twi_status == TW_MT_SLA_NACK) || (twi_status == TW_MT_ARB_LOST)) goto twi_retry;  //TWSR status
     9b2:	8f 81       	ldd	r24, Y+7	; 0x07
     9b4:	80 32       	cpi	r24, 0x20	; 32
     9b6:	91 f2       	breq	.-92     	; 0x95c <twi_mcp_read+0x1e>
     9b8:	8f 81       	ldd	r24, Y+7	; 0x07
     9ba:	88 33       	cpi	r24, 0x38	; 56
     9bc:	79 f2       	breq	.-98     	; 0x95c <twi_mcp_read+0x1e>
        if (twi_status != TW_MT_SLA_ACK) goto twi_quit;
     9be:	8f 81       	ldd	r24, Y+7	; 0x07
     9c0:	88 31       	cpi	r24, 0x18	; 24
     9c2:	d9 f5       	brne	.+118    	; 0xa3a <twi_mcp_read+0xfc>

        set = TWDR;
     9c4:	eb eb       	ldi	r30, 0xBB	; 187
     9c6:	f0 e0       	ldi	r31, 0x00	; 0
     9c8:	80 81       	ld	r24, Z
     9ca:	8d 83       	std	Y+5, r24	; 0x05
        mcp_data[0] = set;
     9cc:	8d 81       	ldd	r24, Y+5	; 0x05
     9ce:	88 2f       	mov	r24, r24
     9d0:	90 e0       	ldi	r25, 0x00	; 0
     9d2:	90 93 18 01 	sts	0x0118, r25
     9d6:	80 93 17 01 	sts	0x0117, r24
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     9da:	8f 81       	ldd	r24, Y+7	; 0x07
     9dc:	88 32       	cpi	r24, 0x28	; 40
     9de:	69 f5       	brne	.+90     	; 0xa3a <twi_mcp_read+0xfc>

        first = TWDR;
     9e0:	eb eb       	ldi	r30, 0xBB	; 187
     9e2:	f0 e0       	ldi	r31, 0x00	; 0
     9e4:	80 81       	ld	r24, Z
     9e6:	8c 83       	std	Y+4, r24	; 0x04
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     9e8:	8f 81       	ldd	r24, Y+7	; 0x07
     9ea:	88 32       	cpi	r24, 0x28	; 40
     9ec:	31 f5       	brne	.+76     	; 0xa3a <twi_mcp_read+0xfc>

        second = TWDR;
     9ee:	eb eb       	ldi	r30, 0xBB	; 187
     9f0:	f0 e0       	ldi	r31, 0x00	; 0
     9f2:	80 81       	ld	r24, Z
     9f4:	8b 83       	std	Y+3, r24	; 0x03
        mcp_data[1] = (first | (second >> 8));
     9f6:	8c 81       	ldd	r24, Y+4	; 0x04
     9f8:	28 2f       	mov	r18, r24
     9fa:	30 e0       	ldi	r19, 0x00	; 0
     9fc:	8b 81       	ldd	r24, Y+3	; 0x03
     9fe:	88 2f       	mov	r24, r24
     a00:	90 e0       	ldi	r25, 0x00	; 0
     a02:	89 2f       	mov	r24, r25
     a04:	99 0f       	add	r25, r25
     a06:	99 0b       	sbc	r25, r25
     a08:	82 2b       	or	r24, r18
     a0a:	93 2b       	or	r25, r19
     a0c:	90 93 1a 01 	sts	0x011A, r25
     a10:	80 93 19 01 	sts	0x0119, r24
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     a14:	8f 81       	ldd	r24, Y+7	; 0x07
     a16:	88 32       	cpi	r24, 0x28	; 40
     a18:	81 f4       	brne	.+32     	; 0xa3a <twi_mcp_read+0xfc>

        all_first = TWDR;
     a1a:	eb eb       	ldi	r30, 0xBB	; 187
     a1c:	f0 e0       	ldi	r31, 0x00	; 0
     a1e:	80 81       	ld	r24, Z
     a20:	8a 83       	std	Y+2, r24	; 0x02
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     a22:	8f 81       	ldd	r24, Y+7	; 0x07
     a24:	88 32       	cpi	r24, 0x28	; 40
     a26:	49 f4       	brne	.+18     	; 0xa3a <twi_mcp_read+0xfc>

        all_second = TWDR;
     a28:	eb eb       	ldi	r30, 0xBB	; 187
     a2a:	f0 e0       	ldi	r31, 0x00	; 0
     a2c:	80 81       	ld	r24, Z
     a2e:	89 83       	std	Y+1, r24	; 0x01

        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     a30:	8f 81       	ldd	r24, Y+7	; 0x07
     a32:	88 32       	cpi	r24, 0x28	; 40
     a34:	11 f4       	brne	.+4      	; 0xa3a <twi_mcp_read+0xfc>
        r_val=1;
     a36:	81 e0       	ldi	r24, 0x01	; 1
     a38:	8e 83       	std	Y+6, r24	; 0x06

    twi_quit:
        //and finally stop
        twi_status=twi_tran(TWI_STOP);  //Transmit
     a3a:	82 e0       	ldi	r24, 0x02	; 2
     a3c:	0e 94 ab 03 	call	0x756	; 0x756 <twi_tran>
     a40:	8f 83       	std	Y+7, r24	; 0x07
        return r_val;
     a42:	8e 81       	ldd	r24, Y+6	; 0x06
     a44:	28 2f       	mov	r18, r24
     a46:	33 27       	eor	r19, r19
     a48:	27 fd       	sbrc	r18, 7
     a4a:	30 95       	com	r19
     a4c:	3c 87       	std	Y+12, r19	; 0x0c
     a4e:	2b 87       	std	Y+11, r18	; 0x0b
     a50:	8b 85       	ldd	r24, Y+11	; 0x0b
     a52:	9c 85       	ldd	r25, Y+12	; 0x0c
}
     a54:	2d 96       	adiw	r28, 0x0d	; 13
     a56:	0f b6       	in	r0, 0x3f	; 63
     a58:	f8 94       	cli
     a5a:	de bf       	out	0x3e, r29	; 62
     a5c:	0f be       	out	0x3f, r0	; 63
     a5e:	cd bf       	out	0x3d, r28	; 61
     a60:	cf 91       	pop	r28
     a62:	df 91       	pop	r29
     a64:	08 95       	ret

00000a66 <main>:
freenode/#linuxandsci - JoshAshby
*/
//-------------------------------------------
#include "global.h"

int main(void) { //Main loop, runs once but can have an infinit loop in it
     a66:	df 93       	push	r29
     a68:	cf 93       	push	r28
     a6a:	cd b7       	in	r28, 0x3d	; 61
     a6c:	de b7       	in	r29, 0x3e	; 62

    bios();
     a6e:	0e 94 b4 01 	call	0x368	; 0x368 <bios>
    calibrate(1);
     a72:	81 e0       	ldi	r24, 0x01	; 1
     a74:	0e 94 8f 06 	call	0xd1e	; 0xd1e <calibrate>
    uart_sendchar("Hello");
     a78:	80 e0       	ldi	r24, 0x00	; 0
     a7a:	91 e0       	ldi	r25, 0x01	; 1
     a7c:	0e 94 5f 09 	call	0x12be	; 0x12be <uart_sendchar>

    while(1) { //infinit loop that doesn't stop running. (always true since 1 is always 1
        check_buttons(); //debounces the buttons with the aid of the timer0 interrupt
     a80:	0e 94 0b 03 	call	0x616	; 0x616 <check_buttons>
        buttons(); //if a buttons been pressed, code inside of here will run, if not
     a84:	0e 94 36 03 	call	0x66c	; 0x66c <buttons>
     a88:	fb cf       	rjmp	.-10     	; 0xa80 <main+0x1a>

00000a8a <pwm_setup_all>:
freenode/#linuxandsci - JoshAshby
*/
//-------------------------------------------
#include "global.h"

void pwm_setup_all(void) {
     a8a:	df 93       	push	r29
     a8c:	cf 93       	push	r28
     a8e:	cd b7       	in	r28, 0x3d	; 61
     a90:	de b7       	in	r29, 0x3e	; 62
    TCCR0B |= (1<<CS00)
     a92:	a5 e4       	ldi	r26, 0x45	; 69
     a94:	b0 e0       	ldi	r27, 0x00	; 0
     a96:	e5 e4       	ldi	r30, 0x45	; 69
     a98:	f0 e0       	ldi	r31, 0x00	; 0
     a9a:	80 81       	ld	r24, Z
     a9c:	83 60       	ori	r24, 0x03	; 3
     a9e:	8c 93       	st	X, r24
            | (1<<CS01); //set timerO clock prescaler to 64
    TCCR0A |= (1<<WGM00);//fast pwm with top as 0xFF
     aa0:	a4 e4       	ldi	r26, 0x44	; 68
     aa2:	b0 e0       	ldi	r27, 0x00	; 0
     aa4:	e4 e4       	ldi	r30, 0x44	; 68
     aa6:	f0 e0       	ldi	r31, 0x00	; 0
     aa8:	80 81       	ld	r24, Z
     aaa:	81 60       	ori	r24, 0x01	; 1
     aac:	8c 93       	st	X, r24

    DDRD |= (1<<5);
     aae:	aa e2       	ldi	r26, 0x2A	; 42
     ab0:	b0 e0       	ldi	r27, 0x00	; 0
     ab2:	ea e2       	ldi	r30, 0x2A	; 42
     ab4:	f0 e0       	ldi	r31, 0x00	; 0
     ab6:	80 81       	ld	r24, Z
     ab8:	80 62       	ori	r24, 0x20	; 32
     aba:	8c 93       	st	X, r24
    DDRD |= (1<<6); //set the OCR0 pins as outputs
     abc:	aa e2       	ldi	r26, 0x2A	; 42
     abe:	b0 e0       	ldi	r27, 0x00	; 0
     ac0:	ea e2       	ldi	r30, 0x2A	; 42
     ac2:	f0 e0       	ldi	r31, 0x00	; 0
     ac4:	80 81       	ld	r24, Z
     ac6:	80 64       	ori	r24, 0x40	; 64
     ac8:	8c 93       	st	X, r24

    TCCR1B |= (1<<CS11)
     aca:	a1 e8       	ldi	r26, 0x81	; 129
     acc:	b0 e0       	ldi	r27, 0x00	; 0
     ace:	e1 e8       	ldi	r30, 0x81	; 129
     ad0:	f0 e0       	ldi	r31, 0x00	; 0
     ad2:	80 81       	ld	r24, Z
     ad4:	83 60       	ori	r24, 0x03	; 3
     ad6:	8c 93       	st	X, r24
            | (1<<CS10);//set timer1 clock prescaler to 64
    TCCR1A |= (1<<WGM10)
     ad8:	a0 e8       	ldi	r26, 0x80	; 128
     ada:	b0 e0       	ldi	r27, 0x00	; 0
     adc:	e0 e8       	ldi	r30, 0x80	; 128
     ade:	f0 e0       	ldi	r31, 0x00	; 0
     ae0:	80 81       	ld	r24, Z
     ae2:	83 60       	ori	r24, 0x03	; 3
     ae4:	8c 93       	st	X, r24
            | (1<<WGM11); //fast pwm (10bit) with top as 0x03FF

    DDRB |= (1<<1);
     ae6:	a4 e2       	ldi	r26, 0x24	; 36
     ae8:	b0 e0       	ldi	r27, 0x00	; 0
     aea:	e4 e2       	ldi	r30, 0x24	; 36
     aec:	f0 e0       	ldi	r31, 0x00	; 0
     aee:	80 81       	ld	r24, Z
     af0:	82 60       	ori	r24, 0x02	; 2
     af2:	8c 93       	st	X, r24
    DDRB |= (1<<2);//set the OCR1 pins as outputs
     af4:	a4 e2       	ldi	r26, 0x24	; 36
     af6:	b0 e0       	ldi	r27, 0x00	; 0
     af8:	e4 e2       	ldi	r30, 0x24	; 36
     afa:	f0 e0       	ldi	r31, 0x00	; 0
     afc:	80 81       	ld	r24, Z
     afe:	84 60       	ori	r24, 0x04	; 4
     b00:	8c 93       	st	X, r24

    TCCR2B |= (1<<CS22);//set timer2 clock prescaler to 64
     b02:	a1 eb       	ldi	r26, 0xB1	; 177
     b04:	b0 e0       	ldi	r27, 0x00	; 0
     b06:	e1 eb       	ldi	r30, 0xB1	; 177
     b08:	f0 e0       	ldi	r31, 0x00	; 0
     b0a:	80 81       	ld	r24, Z
     b0c:	84 60       	ori	r24, 0x04	; 4
     b0e:	8c 93       	st	X, r24
    TCCR2A |= (1<<WGM20);//fast pwm with top as 0xFF
     b10:	a0 eb       	ldi	r26, 0xB0	; 176
     b12:	b0 e0       	ldi	r27, 0x00	; 0
     b14:	e0 eb       	ldi	r30, 0xB0	; 176
     b16:	f0 e0       	ldi	r31, 0x00	; 0
     b18:	80 81       	ld	r24, Z
     b1a:	81 60       	ori	r24, 0x01	; 1
     b1c:	8c 93       	st	X, r24

    DDRD |= (1<<3);
     b1e:	aa e2       	ldi	r26, 0x2A	; 42
     b20:	b0 e0       	ldi	r27, 0x00	; 0
     b22:	ea e2       	ldi	r30, 0x2A	; 42
     b24:	f0 e0       	ldi	r31, 0x00	; 0
     b26:	80 81       	ld	r24, Z
     b28:	88 60       	ori	r24, 0x08	; 8
     b2a:	8c 93       	st	X, r24
    DDRB |= (1<<3); //set the OCR2 pins as outputs
     b2c:	a4 e2       	ldi	r26, 0x24	; 36
     b2e:	b0 e0       	ldi	r27, 0x00	; 0
     b30:	e4 e2       	ldi	r30, 0x24	; 36
     b32:	f0 e0       	ldi	r31, 0x00	; 0
     b34:	80 81       	ld	r24, Z
     b36:	88 60       	ori	r24, 0x08	; 8
     b38:	8c 93       	st	X, r24
}
     b3a:	cf 91       	pop	r28
     b3c:	df 91       	pop	r29
     b3e:	08 95       	ret

00000b40 <pwm_setup0>:

void pwm_setup0(void) {
     b40:	df 93       	push	r29
     b42:	cf 93       	push	r28
     b44:	cd b7       	in	r28, 0x3d	; 61
     b46:	de b7       	in	r29, 0x3e	; 62
    TCCR0B |= (1<<CS00)
     b48:	a5 e4       	ldi	r26, 0x45	; 69
     b4a:	b0 e0       	ldi	r27, 0x00	; 0
     b4c:	e5 e4       	ldi	r30, 0x45	; 69
     b4e:	f0 e0       	ldi	r31, 0x00	; 0
     b50:	80 81       	ld	r24, Z
     b52:	83 60       	ori	r24, 0x03	; 3
     b54:	8c 93       	st	X, r24
            | (1<<CS01);//set timerO clock prescaler to 64
    TCCR0A |= (1<<WGM00);//fast pwm with top as 0xFF
     b56:	a4 e4       	ldi	r26, 0x44	; 68
     b58:	b0 e0       	ldi	r27, 0x00	; 0
     b5a:	e4 e4       	ldi	r30, 0x44	; 68
     b5c:	f0 e0       	ldi	r31, 0x00	; 0
     b5e:	80 81       	ld	r24, Z
     b60:	81 60       	ori	r24, 0x01	; 1
     b62:	8c 93       	st	X, r24

    DDRD |= (1<<5);
     b64:	aa e2       	ldi	r26, 0x2A	; 42
     b66:	b0 e0       	ldi	r27, 0x00	; 0
     b68:	ea e2       	ldi	r30, 0x2A	; 42
     b6a:	f0 e0       	ldi	r31, 0x00	; 0
     b6c:	80 81       	ld	r24, Z
     b6e:	80 62       	ori	r24, 0x20	; 32
     b70:	8c 93       	st	X, r24
    DDRD |= (1<<6);//set the OCR0 pins as outputs
     b72:	aa e2       	ldi	r26, 0x2A	; 42
     b74:	b0 e0       	ldi	r27, 0x00	; 0
     b76:	ea e2       	ldi	r30, 0x2A	; 42
     b78:	f0 e0       	ldi	r31, 0x00	; 0
     b7a:	80 81       	ld	r24, Z
     b7c:	80 64       	ori	r24, 0x40	; 64
     b7e:	8c 93       	st	X, r24
}
     b80:	cf 91       	pop	r28
     b82:	df 91       	pop	r29
     b84:	08 95       	ret

00000b86 <pwm0A>:

void pwm0A(uint8_t value) {
     b86:	df 93       	push	r29
     b88:	cf 93       	push	r28
     b8a:	0f 92       	push	r0
     b8c:	cd b7       	in	r28, 0x3d	; 61
     b8e:	de b7       	in	r29, 0x3e	; 62
     b90:	89 83       	std	Y+1, r24	; 0x01
    TCCR0A |= (1<<COM0A1);
     b92:	a4 e4       	ldi	r26, 0x44	; 68
     b94:	b0 e0       	ldi	r27, 0x00	; 0
     b96:	e4 e4       	ldi	r30, 0x44	; 68
     b98:	f0 e0       	ldi	r31, 0x00	; 0
     b9a:	80 81       	ld	r24, Z
     b9c:	80 68       	ori	r24, 0x80	; 128
     b9e:	8c 93       	st	X, r24
    OCR0A = value;
     ba0:	e7 e4       	ldi	r30, 0x47	; 71
     ba2:	f0 e0       	ldi	r31, 0x00	; 0
     ba4:	89 81       	ldd	r24, Y+1	; 0x01
     ba6:	80 83       	st	Z, r24
}
     ba8:	0f 90       	pop	r0
     baa:	cf 91       	pop	r28
     bac:	df 91       	pop	r29
     bae:	08 95       	ret

00000bb0 <pwm0B>:

void pwm0B(uint8_t value) {
     bb0:	df 93       	push	r29
     bb2:	cf 93       	push	r28
     bb4:	0f 92       	push	r0
     bb6:	cd b7       	in	r28, 0x3d	; 61
     bb8:	de b7       	in	r29, 0x3e	; 62
     bba:	89 83       	std	Y+1, r24	; 0x01
    TCCR0A |= (1<<COM0B1);
     bbc:	a4 e4       	ldi	r26, 0x44	; 68
     bbe:	b0 e0       	ldi	r27, 0x00	; 0
     bc0:	e4 e4       	ldi	r30, 0x44	; 68
     bc2:	f0 e0       	ldi	r31, 0x00	; 0
     bc4:	80 81       	ld	r24, Z
     bc6:	80 62       	ori	r24, 0x20	; 32
     bc8:	8c 93       	st	X, r24
    OCR0B = value;
     bca:	e8 e4       	ldi	r30, 0x48	; 72
     bcc:	f0 e0       	ldi	r31, 0x00	; 0
     bce:	89 81       	ldd	r24, Y+1	; 0x01
     bd0:	80 83       	st	Z, r24
}
     bd2:	0f 90       	pop	r0
     bd4:	cf 91       	pop	r28
     bd6:	df 91       	pop	r29
     bd8:	08 95       	ret

00000bda <pwm_setup1>:

void pwm_setup1(void) {
     bda:	df 93       	push	r29
     bdc:	cf 93       	push	r28
     bde:	cd b7       	in	r28, 0x3d	; 61
     be0:	de b7       	in	r29, 0x3e	; 62
    TCCR1B |= (1<<CS11)
     be2:	a1 e8       	ldi	r26, 0x81	; 129
     be4:	b0 e0       	ldi	r27, 0x00	; 0
     be6:	e1 e8       	ldi	r30, 0x81	; 129
     be8:	f0 e0       	ldi	r31, 0x00	; 0
     bea:	80 81       	ld	r24, Z
     bec:	83 60       	ori	r24, 0x03	; 3
     bee:	8c 93       	st	X, r24
            | (1<<CS10);//set timer1 clock prescaler to 64
    TCCR1A |= (1<<WGM11)
     bf0:	a0 e8       	ldi	r26, 0x80	; 128
     bf2:	b0 e0       	ldi	r27, 0x00	; 0
     bf4:	e0 e8       	ldi	r30, 0x80	; 128
     bf6:	f0 e0       	ldi	r31, 0x00	; 0
     bf8:	80 81       	ld	r24, Z
     bfa:	8a 61       	ori	r24, 0x1A	; 26
     bfc:	8c 93       	st	X, r24
            | (1<<WGM12)
            | (1<<WGM13); //fast pwm (16bit) with top as 0x03FF
    //ICR1H = 0xFF; //set IRC1 to max for full 16bit resolution
    //IRC1L = 0xFF;

    DDRB |= (1<<1);
     bfe:	a4 e2       	ldi	r26, 0x24	; 36
     c00:	b0 e0       	ldi	r27, 0x00	; 0
     c02:	e4 e2       	ldi	r30, 0x24	; 36
     c04:	f0 e0       	ldi	r31, 0x00	; 0
     c06:	80 81       	ld	r24, Z
     c08:	82 60       	ori	r24, 0x02	; 2
     c0a:	8c 93       	st	X, r24
    DDRB |= (1<<2);//set the OCR2 pins as outputs
     c0c:	a4 e2       	ldi	r26, 0x24	; 36
     c0e:	b0 e0       	ldi	r27, 0x00	; 0
     c10:	e4 e2       	ldi	r30, 0x24	; 36
     c12:	f0 e0       	ldi	r31, 0x00	; 0
     c14:	80 81       	ld	r24, Z
     c16:	84 60       	ori	r24, 0x04	; 4
     c18:	8c 93       	st	X, r24
}
     c1a:	cf 91       	pop	r28
     c1c:	df 91       	pop	r29
     c1e:	08 95       	ret

00000c20 <pwm1A>:
void pwm1A(uint16_t value) {
     c20:	df 93       	push	r29
     c22:	cf 93       	push	r28
     c24:	00 d0       	rcall	.+0      	; 0xc26 <pwm1A+0x6>
     c26:	cd b7       	in	r28, 0x3d	; 61
     c28:	de b7       	in	r29, 0x3e	; 62
     c2a:	9a 83       	std	Y+2, r25	; 0x02
     c2c:	89 83       	std	Y+1, r24	; 0x01
    TCCR1A |= (1<<COM1A1);
     c2e:	a0 e8       	ldi	r26, 0x80	; 128
     c30:	b0 e0       	ldi	r27, 0x00	; 0
     c32:	e0 e8       	ldi	r30, 0x80	; 128
     c34:	f0 e0       	ldi	r31, 0x00	; 0
     c36:	80 81       	ld	r24, Z
     c38:	80 68       	ori	r24, 0x80	; 128
     c3a:	8c 93       	st	X, r24
    OCR1A = value;
     c3c:	e8 e8       	ldi	r30, 0x88	; 136
     c3e:	f0 e0       	ldi	r31, 0x00	; 0
     c40:	89 81       	ldd	r24, Y+1	; 0x01
     c42:	9a 81       	ldd	r25, Y+2	; 0x02
     c44:	91 83       	std	Z+1, r25	; 0x01
     c46:	80 83       	st	Z, r24
}
     c48:	0f 90       	pop	r0
     c4a:	0f 90       	pop	r0
     c4c:	cf 91       	pop	r28
     c4e:	df 91       	pop	r29
     c50:	08 95       	ret

00000c52 <pwm1B>:

void pwm1B(uint16_t value) {
     c52:	df 93       	push	r29
     c54:	cf 93       	push	r28
     c56:	00 d0       	rcall	.+0      	; 0xc58 <pwm1B+0x6>
     c58:	cd b7       	in	r28, 0x3d	; 61
     c5a:	de b7       	in	r29, 0x3e	; 62
     c5c:	9a 83       	std	Y+2, r25	; 0x02
     c5e:	89 83       	std	Y+1, r24	; 0x01
    TCCR1A |= (1<<COM1B1);
     c60:	a0 e8       	ldi	r26, 0x80	; 128
     c62:	b0 e0       	ldi	r27, 0x00	; 0
     c64:	e0 e8       	ldi	r30, 0x80	; 128
     c66:	f0 e0       	ldi	r31, 0x00	; 0
     c68:	80 81       	ld	r24, Z
     c6a:	80 62       	ori	r24, 0x20	; 32
     c6c:	8c 93       	st	X, r24
    OCR1B = value;
     c6e:	ea e8       	ldi	r30, 0x8A	; 138
     c70:	f0 e0       	ldi	r31, 0x00	; 0
     c72:	89 81       	ldd	r24, Y+1	; 0x01
     c74:	9a 81       	ldd	r25, Y+2	; 0x02
     c76:	91 83       	std	Z+1, r25	; 0x01
     c78:	80 83       	st	Z, r24
}
     c7a:	0f 90       	pop	r0
     c7c:	0f 90       	pop	r0
     c7e:	cf 91       	pop	r28
     c80:	df 91       	pop	r29
     c82:	08 95       	ret

00000c84 <pwm_setup2>:

void pwm_setup2(void) {
     c84:	df 93       	push	r29
     c86:	cf 93       	push	r28
     c88:	cd b7       	in	r28, 0x3d	; 61
     c8a:	de b7       	in	r29, 0x3e	; 62
    TCCR2B |= (1<<CS22);//set timer2 clock prescaler to 64
     c8c:	a1 eb       	ldi	r26, 0xB1	; 177
     c8e:	b0 e0       	ldi	r27, 0x00	; 0
     c90:	e1 eb       	ldi	r30, 0xB1	; 177
     c92:	f0 e0       	ldi	r31, 0x00	; 0
     c94:	80 81       	ld	r24, Z
     c96:	84 60       	ori	r24, 0x04	; 4
     c98:	8c 93       	st	X, r24
    TCCR2A |= (1<<WGM20);//fast pwm with top as 0xFF
     c9a:	a0 eb       	ldi	r26, 0xB0	; 176
     c9c:	b0 e0       	ldi	r27, 0x00	; 0
     c9e:	e0 eb       	ldi	r30, 0xB0	; 176
     ca0:	f0 e0       	ldi	r31, 0x00	; 0
     ca2:	80 81       	ld	r24, Z
     ca4:	81 60       	ori	r24, 0x01	; 1
     ca6:	8c 93       	st	X, r24

    DDRD |= (1<<3);
     ca8:	aa e2       	ldi	r26, 0x2A	; 42
     caa:	b0 e0       	ldi	r27, 0x00	; 0
     cac:	ea e2       	ldi	r30, 0x2A	; 42
     cae:	f0 e0       	ldi	r31, 0x00	; 0
     cb0:	80 81       	ld	r24, Z
     cb2:	88 60       	ori	r24, 0x08	; 8
     cb4:	8c 93       	st	X, r24
    DDRB |= (1<<3); //set the OCR2 pins as outputs
     cb6:	a4 e2       	ldi	r26, 0x24	; 36
     cb8:	b0 e0       	ldi	r27, 0x00	; 0
     cba:	e4 e2       	ldi	r30, 0x24	; 36
     cbc:	f0 e0       	ldi	r31, 0x00	; 0
     cbe:	80 81       	ld	r24, Z
     cc0:	88 60       	ori	r24, 0x08	; 8
     cc2:	8c 93       	st	X, r24
}
     cc4:	cf 91       	pop	r28
     cc6:	df 91       	pop	r29
     cc8:	08 95       	ret

00000cca <pwm2A>:

void pwm2A(uint8_t value) {
     cca:	df 93       	push	r29
     ccc:	cf 93       	push	r28
     cce:	0f 92       	push	r0
     cd0:	cd b7       	in	r28, 0x3d	; 61
     cd2:	de b7       	in	r29, 0x3e	; 62
     cd4:	89 83       	std	Y+1, r24	; 0x01
    TCCR2A |= (1<<COM2A1);
     cd6:	a0 eb       	ldi	r26, 0xB0	; 176
     cd8:	b0 e0       	ldi	r27, 0x00	; 0
     cda:	e0 eb       	ldi	r30, 0xB0	; 176
     cdc:	f0 e0       	ldi	r31, 0x00	; 0
     cde:	80 81       	ld	r24, Z
     ce0:	80 68       	ori	r24, 0x80	; 128
     ce2:	8c 93       	st	X, r24
    OCR2A = value;
     ce4:	e3 eb       	ldi	r30, 0xB3	; 179
     ce6:	f0 e0       	ldi	r31, 0x00	; 0
     ce8:	89 81       	ldd	r24, Y+1	; 0x01
     cea:	80 83       	st	Z, r24
}
     cec:	0f 90       	pop	r0
     cee:	cf 91       	pop	r28
     cf0:	df 91       	pop	r29
     cf2:	08 95       	ret

00000cf4 <pwm2B>:

void pwm2B(uint8_t value) {
     cf4:	df 93       	push	r29
     cf6:	cf 93       	push	r28
     cf8:	0f 92       	push	r0
     cfa:	cd b7       	in	r28, 0x3d	; 61
     cfc:	de b7       	in	r29, 0x3e	; 62
     cfe:	89 83       	std	Y+1, r24	; 0x01
    TCCR2A |= (1<<COM2B1);
     d00:	a0 eb       	ldi	r26, 0xB0	; 176
     d02:	b0 e0       	ldi	r27, 0x00	; 0
     d04:	e0 eb       	ldi	r30, 0xB0	; 176
     d06:	f0 e0       	ldi	r31, 0x00	; 0
     d08:	80 81       	ld	r24, Z
     d0a:	80 62       	ori	r24, 0x20	; 32
     d0c:	8c 93       	st	X, r24
    OCR2B = value;
     d0e:	e4 eb       	ldi	r30, 0xB4	; 180
     d10:	f0 e0       	ldi	r31, 0x00	; 0
     d12:	89 81       	ldd	r24, Y+1	; 0x01
     d14:	80 83       	st	Z, r24
}
     d16:	0f 90       	pop	r0
     d18:	cf 91       	pop	r28
     d1a:	df 91       	pop	r29
     d1c:	08 95       	ret

00000d1e <calibrate>:
freenode/#linuxandsci - JoshAshby
*/
//-------------------------------------------
#include "global.h"

void calibrate(char pin) {
     d1e:	df 93       	push	r29
     d20:	cf 93       	push	r28
     d22:	cd b7       	in	r28, 0x3d	; 61
     d24:	de b7       	in	r29, 0x3e	; 62
     d26:	2f 97       	sbiw	r28, 0x0f	; 15
     d28:	0f b6       	in	r0, 0x3f	; 63
     d2a:	f8 94       	cli
     d2c:	de bf       	out	0x3e, r29	; 62
     d2e:	0f be       	out	0x3f, r0	; 63
     d30:	cd bf       	out	0x3d, r28	; 61
     d32:	8f 87       	std	Y+15, r24	; 0x0f
    /*
    sets up the rolling average, and fills it with data but only once,
    This is ran once and only once at the very begining of the code for BOB because it
    tells BOB how far from the wall he should be
    */
    adc_change(pin);
     d34:	8f 85       	ldd	r24, Y+15	; 0x0f
     d36:	0e 94 b0 00 	call	0x160	; 0x160 <adc_change>
     d3a:	80 e0       	ldi	r24, 0x00	; 0
     d3c:	90 e0       	ldi	r25, 0x00	; 0
     d3e:	a0 ea       	ldi	r26, 0xA0	; 160
     d40:	b1 e4       	ldi	r27, 0x41	; 65
     d42:	8b 87       	std	Y+11, r24	; 0x0b
     d44:	9c 87       	std	Y+12, r25	; 0x0c
     d46:	ad 87       	std	Y+13, r26	; 0x0d
     d48:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     d4a:	6b 85       	ldd	r22, Y+11	; 0x0b
     d4c:	7c 85       	ldd	r23, Y+12	; 0x0c
     d4e:	8d 85       	ldd	r24, Y+13	; 0x0d
     d50:	9e 85       	ldd	r25, Y+14	; 0x0e
     d52:	20 e0       	ldi	r18, 0x00	; 0
     d54:	30 e0       	ldi	r19, 0x00	; 0
     d56:	4a e7       	ldi	r20, 0x7A	; 122
     d58:	55 e4       	ldi	r21, 0x45	; 69
     d5a:	0e 94 d2 0b 	call	0x17a4	; 0x17a4 <__mulsf3>
     d5e:	dc 01       	movw	r26, r24
     d60:	cb 01       	movw	r24, r22
     d62:	8f 83       	std	Y+7, r24	; 0x07
     d64:	98 87       	std	Y+8, r25	; 0x08
     d66:	a9 87       	std	Y+9, r26	; 0x09
     d68:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
     d6a:	6f 81       	ldd	r22, Y+7	; 0x07
     d6c:	78 85       	ldd	r23, Y+8	; 0x08
     d6e:	89 85       	ldd	r24, Y+9	; 0x09
     d70:	9a 85       	ldd	r25, Y+10	; 0x0a
     d72:	20 e0       	ldi	r18, 0x00	; 0
     d74:	30 e0       	ldi	r19, 0x00	; 0
     d76:	40 e8       	ldi	r20, 0x80	; 128
     d78:	5f e3       	ldi	r21, 0x3F	; 63
     d7a:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <__ltsf2>
     d7e:	88 23       	and	r24, r24
     d80:	2c f4       	brge	.+10     	; 0xd8c <calibrate+0x6e>
		__ticks = 1;
     d82:	81 e0       	ldi	r24, 0x01	; 1
     d84:	90 e0       	ldi	r25, 0x00	; 0
     d86:	9e 83       	std	Y+6, r25	; 0x06
     d88:	8d 83       	std	Y+5, r24	; 0x05
     d8a:	3f c0       	rjmp	.+126    	; 0xe0a <calibrate+0xec>
	else if (__tmp > 65535)
     d8c:	6f 81       	ldd	r22, Y+7	; 0x07
     d8e:	78 85       	ldd	r23, Y+8	; 0x08
     d90:	89 85       	ldd	r24, Y+9	; 0x09
     d92:	9a 85       	ldd	r25, Y+10	; 0x0a
     d94:	20 e0       	ldi	r18, 0x00	; 0
     d96:	3f ef       	ldi	r19, 0xFF	; 255
     d98:	4f e7       	ldi	r20, 0x7F	; 127
     d9a:	57 e4       	ldi	r21, 0x47	; 71
     d9c:	0e 94 cc 0c 	call	0x1998	; 0x1998 <__gtsf2>
     da0:	18 16       	cp	r1, r24
     da2:	4c f5       	brge	.+82     	; 0xdf6 <calibrate+0xd8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     da4:	6b 85       	ldd	r22, Y+11	; 0x0b
     da6:	7c 85       	ldd	r23, Y+12	; 0x0c
     da8:	8d 85       	ldd	r24, Y+13	; 0x0d
     daa:	9e 85       	ldd	r25, Y+14	; 0x0e
     dac:	20 e0       	ldi	r18, 0x00	; 0
     dae:	30 e0       	ldi	r19, 0x00	; 0
     db0:	40 e2       	ldi	r20, 0x20	; 32
     db2:	51 e4       	ldi	r21, 0x41	; 65
     db4:	0e 94 d2 0b 	call	0x17a4	; 0x17a4 <__mulsf3>
     db8:	dc 01       	movw	r26, r24
     dba:	cb 01       	movw	r24, r22
     dbc:	bc 01       	movw	r22, r24
     dbe:	cd 01       	movw	r24, r26
     dc0:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <__fixunssfsi>
     dc4:	dc 01       	movw	r26, r24
     dc6:	cb 01       	movw	r24, r22
     dc8:	9e 83       	std	Y+6, r25	; 0x06
     dca:	8d 83       	std	Y+5, r24	; 0x05
     dcc:	0f c0       	rjmp	.+30     	; 0xdec <calibrate+0xce>
     dce:	80 e9       	ldi	r24, 0x90	; 144
     dd0:	91 e0       	ldi	r25, 0x01	; 1
     dd2:	9c 83       	std	Y+4, r25	; 0x04
     dd4:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     dd6:	8b 81       	ldd	r24, Y+3	; 0x03
     dd8:	9c 81       	ldd	r25, Y+4	; 0x04
     dda:	01 97       	sbiw	r24, 0x01	; 1
     ddc:	f1 f7       	brne	.-4      	; 0xdda <calibrate+0xbc>
     dde:	9c 83       	std	Y+4, r25	; 0x04
     de0:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     de2:	8d 81       	ldd	r24, Y+5	; 0x05
     de4:	9e 81       	ldd	r25, Y+6	; 0x06
     de6:	01 97       	sbiw	r24, 0x01	; 1
     de8:	9e 83       	std	Y+6, r25	; 0x06
     dea:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     dec:	8d 81       	ldd	r24, Y+5	; 0x05
     dee:	9e 81       	ldd	r25, Y+6	; 0x06
     df0:	00 97       	sbiw	r24, 0x00	; 0
     df2:	69 f7       	brne	.-38     	; 0xdce <calibrate+0xb0>
     df4:	14 c0       	rjmp	.+40     	; 0xe1e <calibrate+0x100>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     df6:	6f 81       	ldd	r22, Y+7	; 0x07
     df8:	78 85       	ldd	r23, Y+8	; 0x08
     dfa:	89 85       	ldd	r24, Y+9	; 0x09
     dfc:	9a 85       	ldd	r25, Y+10	; 0x0a
     dfe:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <__fixunssfsi>
     e02:	dc 01       	movw	r26, r24
     e04:	cb 01       	movw	r24, r22
     e06:	9e 83       	std	Y+6, r25	; 0x06
     e08:	8d 83       	std	Y+5, r24	; 0x05
     e0a:	8d 81       	ldd	r24, Y+5	; 0x05
     e0c:	9e 81       	ldd	r25, Y+6	; 0x06
     e0e:	9a 83       	std	Y+2, r25	; 0x02
     e10:	89 83       	std	Y+1, r24	; 0x01
     e12:	89 81       	ldd	r24, Y+1	; 0x01
     e14:	9a 81       	ldd	r25, Y+2	; 0x02
     e16:	01 97       	sbiw	r24, 0x01	; 1
     e18:	f1 f7       	brne	.-4      	; 0xe16 <calibrate+0xf8>
     e1a:	9a 83       	std	Y+2, r25	; 0x02
     e1c:	89 83       	std	Y+1, r24	; 0x01
    _delay_ms(20); //need to get rid of this ugly delay, may replace it with timer2 interrupt
    adc = ADCH;
     e1e:	e9 e7       	ldi	r30, 0x79	; 121
     e20:	f0 e0       	ldi	r31, 0x00	; 0
     e22:	80 81       	ld	r24, Z
     e24:	88 2f       	mov	r24, r24
     e26:	90 e0       	ldi	r25, 0x00	; 0
     e28:	90 93 d8 03 	sts	0x03D8, r25
     e2c:	80 93 d7 03 	sts	0x03D7, r24
    for (j = 0; j <= 20; j++){
     e30:	10 92 10 01 	sts	0x0110, r1
     e34:	51 c0       	rjmp	.+162    	; 0xed8 <calibrate+0x1ba>
        if (ADCH > average + 100)
     e36:	e9 e7       	ldi	r30, 0x79	; 121
     e38:	f0 e0       	ldi	r31, 0x00	; 0
     e3a:	80 81       	ld	r24, Z
     e3c:	28 2f       	mov	r18, r24
     e3e:	30 e0       	ldi	r19, 0x00	; 0
     e40:	80 91 11 01 	lds	r24, 0x0111
     e44:	90 91 12 01 	lds	r25, 0x0112
     e48:	8c 59       	subi	r24, 0x9C	; 156
     e4a:	9f 4f       	sbci	r25, 0xFF	; 255
     e4c:	82 17       	cp	r24, r18
     e4e:	93 07       	cpc	r25, r19
     e50:	90 f4       	brcc	.+36     	; 0xe76 <calibrate+0x158>
        {
            adc = (ADCH/2) + (average/2);
     e52:	e9 e7       	ldi	r30, 0x79	; 121
     e54:	f0 e0       	ldi	r31, 0x00	; 0
     e56:	80 81       	ld	r24, Z
     e58:	86 95       	lsr	r24
     e5a:	28 2f       	mov	r18, r24
     e5c:	30 e0       	ldi	r19, 0x00	; 0
     e5e:	80 91 11 01 	lds	r24, 0x0111
     e62:	90 91 12 01 	lds	r25, 0x0112
     e66:	96 95       	lsr	r25
     e68:	87 95       	ror	r24
     e6a:	82 0f       	add	r24, r18
     e6c:	93 1f       	adc	r25, r19
     e6e:	90 93 d8 03 	sts	0x03D8, r25
     e72:	80 93 d7 03 	sts	0x03D7, r24
        }
        if (ADCH < average - 100){
     e76:	e9 e7       	ldi	r30, 0x79	; 121
     e78:	f0 e0       	ldi	r31, 0x00	; 0
     e7a:	80 81       	ld	r24, Z
     e7c:	28 2f       	mov	r18, r24
     e7e:	30 e0       	ldi	r19, 0x00	; 0
     e80:	80 91 11 01 	lds	r24, 0x0111
     e84:	90 91 12 01 	lds	r25, 0x0112
     e88:	84 56       	subi	r24, 0x64	; 100
     e8a:	90 40       	sbci	r25, 0x00	; 0
     e8c:	28 17       	cp	r18, r24
     e8e:	39 07       	cpc	r19, r25
     e90:	90 f4       	brcc	.+36     	; 0xeb6 <calibrate+0x198>
            adc = (ADCH/2) + (average/2);
     e92:	e9 e7       	ldi	r30, 0x79	; 121
     e94:	f0 e0       	ldi	r31, 0x00	; 0
     e96:	80 81       	ld	r24, Z
     e98:	86 95       	lsr	r24
     e9a:	28 2f       	mov	r18, r24
     e9c:	30 e0       	ldi	r19, 0x00	; 0
     e9e:	80 91 11 01 	lds	r24, 0x0111
     ea2:	90 91 12 01 	lds	r25, 0x0112
     ea6:	96 95       	lsr	r25
     ea8:	87 95       	ror	r24
     eaa:	82 0f       	add	r24, r18
     eac:	93 1f       	adc	r25, r19
     eae:	90 93 d8 03 	sts	0x03D8, r25
     eb2:	80 93 d7 03 	sts	0x03D7, r24
        }
        rollAverage[j] = adc;
     eb6:	80 91 10 01 	lds	r24, 0x0110
     eba:	28 2f       	mov	r18, r24
     ebc:	30 e0       	ldi	r19, 0x00	; 0
     ebe:	80 91 d7 03 	lds	r24, 0x03D7
     ec2:	90 91 d8 03 	lds	r25, 0x03D8
     ec6:	f9 01       	movw	r30, r18
     ec8:	e5 52       	subi	r30, 0x25	; 37
     eca:	fc 4f       	sbci	r31, 0xFC	; 252
     ecc:	80 83       	st	Z, r24
    tells BOB how far from the wall he should be
    */
    adc_change(pin);
    _delay_ms(20); //need to get rid of this ugly delay, may replace it with timer2 interrupt
    adc = ADCH;
    for (j = 0; j <= 20; j++){
     ece:	80 91 10 01 	lds	r24, 0x0110
     ed2:	8f 5f       	subi	r24, 0xFF	; 255
     ed4:	80 93 10 01 	sts	0x0110, r24
     ed8:	80 91 10 01 	lds	r24, 0x0110
     edc:	85 31       	cpi	r24, 0x15	; 21
     ede:	08 f4       	brcc	.+2      	; 0xee2 <calibrate+0x1c4>
     ee0:	aa cf       	rjmp	.-172    	; 0xe36 <calibrate+0x118>
        if (ADCH < average - 100){
            adc = (ADCH/2) + (average/2);
        }
        rollAverage[j] = adc;
    }
    for (j = 0; j <= 20; j++){
     ee2:	10 92 10 01 	sts	0x0110, r1
     ee6:	19 c0       	rjmp	.+50     	; 0xf1a <calibrate+0x1fc>
        average += rollAverage[j];
     ee8:	80 91 10 01 	lds	r24, 0x0110
     eec:	88 2f       	mov	r24, r24
     eee:	90 e0       	ldi	r25, 0x00	; 0
     ef0:	fc 01       	movw	r30, r24
     ef2:	e5 52       	subi	r30, 0x25	; 37
     ef4:	fc 4f       	sbci	r31, 0xFC	; 252
     ef6:	80 81       	ld	r24, Z
     ef8:	28 2f       	mov	r18, r24
     efa:	30 e0       	ldi	r19, 0x00	; 0
     efc:	80 91 11 01 	lds	r24, 0x0111
     f00:	90 91 12 01 	lds	r25, 0x0112
     f04:	82 0f       	add	r24, r18
     f06:	93 1f       	adc	r25, r19
     f08:	90 93 12 01 	sts	0x0112, r25
     f0c:	80 93 11 01 	sts	0x0111, r24
        if (ADCH < average - 100){
            adc = (ADCH/2) + (average/2);
        }
        rollAverage[j] = adc;
    }
    for (j = 0; j <= 20; j++){
     f10:	80 91 10 01 	lds	r24, 0x0110
     f14:	8f 5f       	subi	r24, 0xFF	; 255
     f16:	80 93 10 01 	sts	0x0110, r24
     f1a:	80 91 10 01 	lds	r24, 0x0110
     f1e:	85 31       	cpi	r24, 0x15	; 21
     f20:	18 f3       	brcs	.-58     	; 0xee8 <calibrate+0x1ca>
        average += rollAverage[j];
    }
    average = average/18;
     f22:	80 91 11 01 	lds	r24, 0x0111
     f26:	90 91 12 01 	lds	r25, 0x0112
     f2a:	22 e1       	ldi	r18, 0x12	; 18
     f2c:	30 e0       	ldi	r19, 0x00	; 0
     f2e:	b9 01       	movw	r22, r18
     f30:	0e 94 56 0f 	call	0x1eac	; 0x1eac <__udivmodhi4>
     f34:	cb 01       	movw	r24, r22
     f36:	90 93 12 01 	sts	0x0112, r25
     f3a:	80 93 11 01 	sts	0x0111, r24
    base = average;
     f3e:	80 91 11 01 	lds	r24, 0x0111
     f42:	90 91 12 01 	lds	r25, 0x0112
     f46:	90 93 0f 01 	sts	0x010F, r25
     f4a:	80 93 0e 01 	sts	0x010E, r24
    for (j = 0; j <= 20; j++){
     f4e:	10 92 10 01 	sts	0x0110, r1
     f52:	0d c0       	rjmp	.+26     	; 0xf6e <calibrate+0x250>
        rollAverage[j] = 0;
     f54:	80 91 10 01 	lds	r24, 0x0110
     f58:	88 2f       	mov	r24, r24
     f5a:	90 e0       	ldi	r25, 0x00	; 0
     f5c:	fc 01       	movw	r30, r24
     f5e:	e5 52       	subi	r30, 0x25	; 37
     f60:	fc 4f       	sbci	r31, 0xFC	; 252
     f62:	10 82       	st	Z, r1
    for (j = 0; j <= 20; j++){
        average += rollAverage[j];
    }
    average = average/18;
    base = average;
    for (j = 0; j <= 20; j++){
     f64:	80 91 10 01 	lds	r24, 0x0110
     f68:	8f 5f       	subi	r24, 0xFF	; 255
     f6a:	80 93 10 01 	sts	0x0110, r24
     f6e:	80 91 10 01 	lds	r24, 0x0110
     f72:	85 31       	cpi	r24, 0x15	; 21
     f74:	78 f3       	brcs	.-34     	; 0xf54 <calibrate+0x236>
        rollAverage[j] = 0;
    }
}
     f76:	2f 96       	adiw	r28, 0x0f	; 15
     f78:	0f b6       	in	r0, 0x3f	; 63
     f7a:	f8 94       	cli
     f7c:	de bf       	out	0x3e, r29	; 62
     f7e:	0f be       	out	0x3f, r0	; 63
     f80:	cd bf       	out	0x3d, r28	; 61
     f82:	cf 91       	pop	r28
     f84:	df 91       	pop	r29
     f86:	08 95       	ret

00000f88 <ultrasound_filter>:

uint16_t ultrasound_filter(char pin) {
     f88:	df 93       	push	r29
     f8a:	cf 93       	push	r28
     f8c:	cd b7       	in	r28, 0x3d	; 61
     f8e:	de b7       	in	r29, 0x3e	; 62
     f90:	2f 97       	sbiw	r28, 0x0f	; 15
     f92:	0f b6       	in	r0, 0x3f	; 63
     f94:	f8 94       	cli
     f96:	de bf       	out	0x3e, r29	; 62
     f98:	0f be       	out	0x3f, r0	; 63
     f9a:	cd bf       	out	0x3d, r28	; 61
     f9c:	8f 87       	std	Y+15, r24	; 0x0f
    /*
    simple filter that works quite well, it simply smooths out the ADC data from the ultrasounds
    if the ADC data is out of range, it will divide it by two, and then add the average divided by two
    */
    adc_change(pin);
     f9e:	8f 85       	ldd	r24, Y+15	; 0x0f
     fa0:	0e 94 b0 00 	call	0x160	; 0x160 <adc_change>
     fa4:	80 e0       	ldi	r24, 0x00	; 0
     fa6:	90 e0       	ldi	r25, 0x00	; 0
     fa8:	a0 ea       	ldi	r26, 0xA0	; 160
     faa:	b1 e4       	ldi	r27, 0x41	; 65
     fac:	8b 87       	std	Y+11, r24	; 0x0b
     fae:	9c 87       	std	Y+12, r25	; 0x0c
     fb0:	ad 87       	std	Y+13, r26	; 0x0d
     fb2:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     fb4:	6b 85       	ldd	r22, Y+11	; 0x0b
     fb6:	7c 85       	ldd	r23, Y+12	; 0x0c
     fb8:	8d 85       	ldd	r24, Y+13	; 0x0d
     fba:	9e 85       	ldd	r25, Y+14	; 0x0e
     fbc:	20 e0       	ldi	r18, 0x00	; 0
     fbe:	30 e0       	ldi	r19, 0x00	; 0
     fc0:	4a e7       	ldi	r20, 0x7A	; 122
     fc2:	55 e4       	ldi	r21, 0x45	; 69
     fc4:	0e 94 d2 0b 	call	0x17a4	; 0x17a4 <__mulsf3>
     fc8:	dc 01       	movw	r26, r24
     fca:	cb 01       	movw	r24, r22
     fcc:	8f 83       	std	Y+7, r24	; 0x07
     fce:	98 87       	std	Y+8, r25	; 0x08
     fd0:	a9 87       	std	Y+9, r26	; 0x09
     fd2:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
     fd4:	6f 81       	ldd	r22, Y+7	; 0x07
     fd6:	78 85       	ldd	r23, Y+8	; 0x08
     fd8:	89 85       	ldd	r24, Y+9	; 0x09
     fda:	9a 85       	ldd	r25, Y+10	; 0x0a
     fdc:	20 e0       	ldi	r18, 0x00	; 0
     fde:	30 e0       	ldi	r19, 0x00	; 0
     fe0:	40 e8       	ldi	r20, 0x80	; 128
     fe2:	5f e3       	ldi	r21, 0x3F	; 63
     fe4:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <__ltsf2>
     fe8:	88 23       	and	r24, r24
     fea:	2c f4       	brge	.+10     	; 0xff6 <ultrasound_filter+0x6e>
		__ticks = 1;
     fec:	81 e0       	ldi	r24, 0x01	; 1
     fee:	90 e0       	ldi	r25, 0x00	; 0
     ff0:	9e 83       	std	Y+6, r25	; 0x06
     ff2:	8d 83       	std	Y+5, r24	; 0x05
     ff4:	3f c0       	rjmp	.+126    	; 0x1074 <ultrasound_filter+0xec>
	else if (__tmp > 65535)
     ff6:	6f 81       	ldd	r22, Y+7	; 0x07
     ff8:	78 85       	ldd	r23, Y+8	; 0x08
     ffa:	89 85       	ldd	r24, Y+9	; 0x09
     ffc:	9a 85       	ldd	r25, Y+10	; 0x0a
     ffe:	20 e0       	ldi	r18, 0x00	; 0
    1000:	3f ef       	ldi	r19, 0xFF	; 255
    1002:	4f e7       	ldi	r20, 0x7F	; 127
    1004:	57 e4       	ldi	r21, 0x47	; 71
    1006:	0e 94 cc 0c 	call	0x1998	; 0x1998 <__gtsf2>
    100a:	18 16       	cp	r1, r24
    100c:	4c f5       	brge	.+82     	; 0x1060 <ultrasound_filter+0xd8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    100e:	6b 85       	ldd	r22, Y+11	; 0x0b
    1010:	7c 85       	ldd	r23, Y+12	; 0x0c
    1012:	8d 85       	ldd	r24, Y+13	; 0x0d
    1014:	9e 85       	ldd	r25, Y+14	; 0x0e
    1016:	20 e0       	ldi	r18, 0x00	; 0
    1018:	30 e0       	ldi	r19, 0x00	; 0
    101a:	40 e2       	ldi	r20, 0x20	; 32
    101c:	51 e4       	ldi	r21, 0x41	; 65
    101e:	0e 94 d2 0b 	call	0x17a4	; 0x17a4 <__mulsf3>
    1022:	dc 01       	movw	r26, r24
    1024:	cb 01       	movw	r24, r22
    1026:	bc 01       	movw	r22, r24
    1028:	cd 01       	movw	r24, r26
    102a:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <__fixunssfsi>
    102e:	dc 01       	movw	r26, r24
    1030:	cb 01       	movw	r24, r22
    1032:	9e 83       	std	Y+6, r25	; 0x06
    1034:	8d 83       	std	Y+5, r24	; 0x05
    1036:	0f c0       	rjmp	.+30     	; 0x1056 <ultrasound_filter+0xce>
    1038:	80 e9       	ldi	r24, 0x90	; 144
    103a:	91 e0       	ldi	r25, 0x01	; 1
    103c:	9c 83       	std	Y+4, r25	; 0x04
    103e:	8b 83       	std	Y+3, r24	; 0x03
    1040:	8b 81       	ldd	r24, Y+3	; 0x03
    1042:	9c 81       	ldd	r25, Y+4	; 0x04
    1044:	01 97       	sbiw	r24, 0x01	; 1
    1046:	f1 f7       	brne	.-4      	; 0x1044 <ultrasound_filter+0xbc>
    1048:	9c 83       	std	Y+4, r25	; 0x04
    104a:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    104c:	8d 81       	ldd	r24, Y+5	; 0x05
    104e:	9e 81       	ldd	r25, Y+6	; 0x06
    1050:	01 97       	sbiw	r24, 0x01	; 1
    1052:	9e 83       	std	Y+6, r25	; 0x06
    1054:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1056:	8d 81       	ldd	r24, Y+5	; 0x05
    1058:	9e 81       	ldd	r25, Y+6	; 0x06
    105a:	00 97       	sbiw	r24, 0x00	; 0
    105c:	69 f7       	brne	.-38     	; 0x1038 <ultrasound_filter+0xb0>
    105e:	14 c0       	rjmp	.+40     	; 0x1088 <ultrasound_filter+0x100>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1060:	6f 81       	ldd	r22, Y+7	; 0x07
    1062:	78 85       	ldd	r23, Y+8	; 0x08
    1064:	89 85       	ldd	r24, Y+9	; 0x09
    1066:	9a 85       	ldd	r25, Y+10	; 0x0a
    1068:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <__fixunssfsi>
    106c:	dc 01       	movw	r26, r24
    106e:	cb 01       	movw	r24, r22
    1070:	9e 83       	std	Y+6, r25	; 0x06
    1072:	8d 83       	std	Y+5, r24	; 0x05
    1074:	8d 81       	ldd	r24, Y+5	; 0x05
    1076:	9e 81       	ldd	r25, Y+6	; 0x06
    1078:	9a 83       	std	Y+2, r25	; 0x02
    107a:	89 83       	std	Y+1, r24	; 0x01
    107c:	89 81       	ldd	r24, Y+1	; 0x01
    107e:	9a 81       	ldd	r25, Y+2	; 0x02
    1080:	01 97       	sbiw	r24, 0x01	; 1
    1082:	f1 f7       	brne	.-4      	; 0x1080 <ultrasound_filter+0xf8>
    1084:	9a 83       	std	Y+2, r25	; 0x02
    1086:	89 83       	std	Y+1, r24	; 0x01
    _delay_ms(20); //need to get rid of this ugly delay, may replace it with timer2 interrupt
    adc = ADCH;
    1088:	e9 e7       	ldi	r30, 0x79	; 121
    108a:	f0 e0       	ldi	r31, 0x00	; 0
    108c:	80 81       	ld	r24, Z
    108e:	88 2f       	mov	r24, r24
    1090:	90 e0       	ldi	r25, 0x00	; 0
    1092:	90 93 d8 03 	sts	0x03D8, r25
    1096:	80 93 d7 03 	sts	0x03D7, r24
    for (j = 0; j <= 30; j++){
    109a:	10 92 10 01 	sts	0x0110, r1
    109e:	51 c0       	rjmp	.+162    	; 0x1142 <ultrasound_filter+0x1ba>
        if (ADCH > average + 100)
    10a0:	e9 e7       	ldi	r30, 0x79	; 121
    10a2:	f0 e0       	ldi	r31, 0x00	; 0
    10a4:	80 81       	ld	r24, Z
    10a6:	28 2f       	mov	r18, r24
    10a8:	30 e0       	ldi	r19, 0x00	; 0
    10aa:	80 91 11 01 	lds	r24, 0x0111
    10ae:	90 91 12 01 	lds	r25, 0x0112
    10b2:	8c 59       	subi	r24, 0x9C	; 156
    10b4:	9f 4f       	sbci	r25, 0xFF	; 255
    10b6:	82 17       	cp	r24, r18
    10b8:	93 07       	cpc	r25, r19
    10ba:	90 f4       	brcc	.+36     	; 0x10e0 <ultrasound_filter+0x158>
        {
            adc = (ADCH/2) + (average/2);
    10bc:	e9 e7       	ldi	r30, 0x79	; 121
    10be:	f0 e0       	ldi	r31, 0x00	; 0
    10c0:	80 81       	ld	r24, Z
    10c2:	86 95       	lsr	r24
    10c4:	28 2f       	mov	r18, r24
    10c6:	30 e0       	ldi	r19, 0x00	; 0
    10c8:	80 91 11 01 	lds	r24, 0x0111
    10cc:	90 91 12 01 	lds	r25, 0x0112
    10d0:	96 95       	lsr	r25
    10d2:	87 95       	ror	r24
    10d4:	82 0f       	add	r24, r18
    10d6:	93 1f       	adc	r25, r19
    10d8:	90 93 d8 03 	sts	0x03D8, r25
    10dc:	80 93 d7 03 	sts	0x03D7, r24
        }
        if (ADCH < average - 100){
    10e0:	e9 e7       	ldi	r30, 0x79	; 121
    10e2:	f0 e0       	ldi	r31, 0x00	; 0
    10e4:	80 81       	ld	r24, Z
    10e6:	28 2f       	mov	r18, r24
    10e8:	30 e0       	ldi	r19, 0x00	; 0
    10ea:	80 91 11 01 	lds	r24, 0x0111
    10ee:	90 91 12 01 	lds	r25, 0x0112
    10f2:	84 56       	subi	r24, 0x64	; 100
    10f4:	90 40       	sbci	r25, 0x00	; 0
    10f6:	28 17       	cp	r18, r24
    10f8:	39 07       	cpc	r19, r25
    10fa:	90 f4       	brcc	.+36     	; 0x1120 <ultrasound_filter+0x198>
            adc = (ADCH/2) + (average/2);
    10fc:	e9 e7       	ldi	r30, 0x79	; 121
    10fe:	f0 e0       	ldi	r31, 0x00	; 0
    1100:	80 81       	ld	r24, Z
    1102:	86 95       	lsr	r24
    1104:	28 2f       	mov	r18, r24
    1106:	30 e0       	ldi	r19, 0x00	; 0
    1108:	80 91 11 01 	lds	r24, 0x0111
    110c:	90 91 12 01 	lds	r25, 0x0112
    1110:	96 95       	lsr	r25
    1112:	87 95       	ror	r24
    1114:	82 0f       	add	r24, r18
    1116:	93 1f       	adc	r25, r19
    1118:	90 93 d8 03 	sts	0x03D8, r25
    111c:	80 93 d7 03 	sts	0x03D7, r24
        }
        rollAverage[j] = adc;
    1120:	80 91 10 01 	lds	r24, 0x0110
    1124:	28 2f       	mov	r18, r24
    1126:	30 e0       	ldi	r19, 0x00	; 0
    1128:	80 91 d7 03 	lds	r24, 0x03D7
    112c:	90 91 d8 03 	lds	r25, 0x03D8
    1130:	f9 01       	movw	r30, r18
    1132:	e5 52       	subi	r30, 0x25	; 37
    1134:	fc 4f       	sbci	r31, 0xFC	; 252
    1136:	80 83       	st	Z, r24
    if the ADC data is out of range, it will divide it by two, and then add the average divided by two
    */
    adc_change(pin);
    _delay_ms(20); //need to get rid of this ugly delay, may replace it with timer2 interrupt
    adc = ADCH;
    for (j = 0; j <= 30; j++){
    1138:	80 91 10 01 	lds	r24, 0x0110
    113c:	8f 5f       	subi	r24, 0xFF	; 255
    113e:	80 93 10 01 	sts	0x0110, r24
    1142:	80 91 10 01 	lds	r24, 0x0110
    1146:	8f 31       	cpi	r24, 0x1F	; 31
    1148:	08 f4       	brcc	.+2      	; 0x114c <ultrasound_filter+0x1c4>
    114a:	aa cf       	rjmp	.-172    	; 0x10a0 <ultrasound_filter+0x118>
        if (ADCH < average - 100){
            adc = (ADCH/2) + (average/2);
        }
        rollAverage[j] = adc;
    }
    for (j = 0; j <= 30; j++){
    114c:	10 92 10 01 	sts	0x0110, r1
    1150:	19 c0       	rjmp	.+50     	; 0x1184 <ultrasound_filter+0x1fc>
        average += rollAverage[j];
    1152:	80 91 10 01 	lds	r24, 0x0110
    1156:	88 2f       	mov	r24, r24
    1158:	90 e0       	ldi	r25, 0x00	; 0
    115a:	fc 01       	movw	r30, r24
    115c:	e5 52       	subi	r30, 0x25	; 37
    115e:	fc 4f       	sbci	r31, 0xFC	; 252
    1160:	80 81       	ld	r24, Z
    1162:	28 2f       	mov	r18, r24
    1164:	30 e0       	ldi	r19, 0x00	; 0
    1166:	80 91 11 01 	lds	r24, 0x0111
    116a:	90 91 12 01 	lds	r25, 0x0112
    116e:	82 0f       	add	r24, r18
    1170:	93 1f       	adc	r25, r19
    1172:	90 93 12 01 	sts	0x0112, r25
    1176:	80 93 11 01 	sts	0x0111, r24
        if (ADCH < average - 100){
            adc = (ADCH/2) + (average/2);
        }
        rollAverage[j] = adc;
    }
    for (j = 0; j <= 30; j++){
    117a:	80 91 10 01 	lds	r24, 0x0110
    117e:	8f 5f       	subi	r24, 0xFF	; 255
    1180:	80 93 10 01 	sts	0x0110, r24
    1184:	80 91 10 01 	lds	r24, 0x0110
    1188:	8f 31       	cpi	r24, 0x1F	; 31
    118a:	18 f3       	brcs	.-58     	; 0x1152 <ultrasound_filter+0x1ca>
        average += rollAverage[j];
    }
    average = average/30;
    118c:	80 91 11 01 	lds	r24, 0x0111
    1190:	90 91 12 01 	lds	r25, 0x0112
    1194:	2e e1       	ldi	r18, 0x1E	; 30
    1196:	30 e0       	ldi	r19, 0x00	; 0
    1198:	b9 01       	movw	r22, r18
    119a:	0e 94 56 0f 	call	0x1eac	; 0x1eac <__udivmodhi4>
    119e:	cb 01       	movw	r24, r22
    11a0:	90 93 12 01 	sts	0x0112, r25
    11a4:	80 93 11 01 	sts	0x0111, r24
    return average;
    11a8:	80 91 11 01 	lds	r24, 0x0111
    11ac:	90 91 12 01 	lds	r25, 0x0112
}
    11b0:	2f 96       	adiw	r28, 0x0f	; 15
    11b2:	0f b6       	in	r0, 0x3f	; 63
    11b4:	f8 94       	cli
    11b6:	de bf       	out	0x3e, r29	; 62
    11b8:	0f be       	out	0x3f, r0	; 63
    11ba:	cd bf       	out	0x3d, r28	; 61
    11bc:	cf 91       	pop	r28
    11be:	df 91       	pop	r29
    11c0:	08 95       	ret

000011c2 <uart_start>:
*/
//-------------------------------------------
#include "global.h"

//Got through and set up the registers for UART
void uart_start(void) {
    11c2:	df 93       	push	r29
    11c4:	cf 93       	push	r28
    11c6:	cd b7       	in	r28, 0x3d	; 61
    11c8:	de b7       	in	r29, 0x3e	; 62
    UCSR0B |= (1 << RXEN0) | (1 << TXEN0); //transmit side of hardware
    11ca:	a1 ec       	ldi	r26, 0xC1	; 193
    11cc:	b0 e0       	ldi	r27, 0x00	; 0
    11ce:	e1 ec       	ldi	r30, 0xC1	; 193
    11d0:	f0 e0       	ldi	r31, 0x00	; 0
    11d2:	80 81       	ld	r24, Z
    11d4:	88 61       	ori	r24, 0x18	; 24
    11d6:	8c 93       	st	X, r24
    UCSR0C |= (1 << UCSZ00) | (1 << UCSZ01); //receive side of hardware
    11d8:	a2 ec       	ldi	r26, 0xC2	; 194
    11da:	b0 e0       	ldi	r27, 0x00	; 0
    11dc:	e2 ec       	ldi	r30, 0xC2	; 194
    11de:	f0 e0       	ldi	r31, 0x00	; 0
    11e0:	80 81       	ld	r24, Z
    11e2:	86 60       	ori	r24, 0x06	; 6
    11e4:	8c 93       	st	X, r24

    UBRR0L = BAUD_PRESCALE; //set the baud to 9600, have to split it into the two registers
    11e6:	e4 ec       	ldi	r30, 0xC4	; 196
    11e8:	f0 e0       	ldi	r31, 0x00	; 0
    11ea:	87 e6       	ldi	r24, 0x67	; 103
    11ec:	80 83       	st	Z, r24
    UBRR0H = (BAUD_PRESCALE >> 8); //high end of baud register
    11ee:	e5 ec       	ldi	r30, 0xC5	; 197
    11f0:	f0 e0       	ldi	r31, 0x00	; 0
    11f2:	10 82       	st	Z, r1

    UCSR0B |= (1 << RXCIE0); //recieve data interrupt, makes sure we don't loose data
    11f4:	a1 ec       	ldi	r26, 0xC1	; 193
    11f6:	b0 e0       	ldi	r27, 0x00	; 0
    11f8:	e1 ec       	ldi	r30, 0xC1	; 193
    11fa:	f0 e0       	ldi	r31, 0x00	; 0
    11fc:	80 81       	ld	r24, Z
    11fe:	80 68       	ori	r24, 0x80	; 128
    1200:	8c 93       	st	X, r24
    sei(); //enable system interrupts
    1202:	78 94       	sei

    while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    1204:	e0 ec       	ldi	r30, 0xC0	; 192
    1206:	f0 e0       	ldi	r31, 0x00	; 0
    1208:	80 81       	ld	r24, Z
    120a:	88 2f       	mov	r24, r24
    120c:	90 e0       	ldi	r25, 0x00	; 0
    120e:	80 72       	andi	r24, 0x20	; 32
    1210:	90 70       	andi	r25, 0x00	; 0
    1212:	00 97       	sbiw	r24, 0x00	; 0
    1214:	b9 f3       	breq	.-18     	; 0x1204 <uart_start+0x42>
	UDR0 = '\n';//send a new line just to be sure
    1216:	e6 ec       	ldi	r30, 0xC6	; 198
    1218:	f0 e0       	ldi	r31, 0x00	; 0
    121a:	8a e0       	ldi	r24, 0x0A	; 10
    121c:	80 83       	st	Z, r24
	while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    121e:	e0 ec       	ldi	r30, 0xC0	; 192
    1220:	f0 e0       	ldi	r31, 0x00	; 0
    1222:	80 81       	ld	r24, Z
    1224:	88 2f       	mov	r24, r24
    1226:	90 e0       	ldi	r25, 0x00	; 0
    1228:	80 72       	andi	r24, 0x20	; 32
    122a:	90 70       	andi	r25, 0x00	; 0
    122c:	00 97       	sbiw	r24, 0x00	; 0
    122e:	b9 f3       	breq	.-18     	; 0x121e <uart_start+0x5c>
	UDR0 = '\r';//send a new line just to be sure
    1230:	e6 ec       	ldi	r30, 0xC6	; 198
    1232:	f0 e0       	ldi	r31, 0x00	; 0
    1234:	8d e0       	ldi	r24, 0x0D	; 13
    1236:	80 83       	st	Z, r24
}
    1238:	cf 91       	pop	r28
    123a:	df 91       	pop	r29
    123c:	08 95       	ret

0000123e <uart_sendint>:

void uart_sendint(uint8_t data) {
    123e:	df 93       	push	r29
    1240:	cf 93       	push	r28
    1242:	0f 92       	push	r0
    1244:	cd b7       	in	r28, 0x3d	; 61
    1246:	de b7       	in	r29, 0x3e	; 62
    1248:	89 83       	std	Y+1, r24	; 0x01
    /*
    Use this to send a 8bit long piece of data
    */
    while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    124a:	e0 ec       	ldi	r30, 0xC0	; 192
    124c:	f0 e0       	ldi	r31, 0x00	; 0
    124e:	80 81       	ld	r24, Z
    1250:	88 2f       	mov	r24, r24
    1252:	90 e0       	ldi	r25, 0x00	; 0
    1254:	80 72       	andi	r24, 0x20	; 32
    1256:	90 70       	andi	r25, 0x00	; 0
    1258:	00 97       	sbiw	r24, 0x00	; 0
    125a:	b9 f3       	breq	.-18     	; 0x124a <uart_sendint+0xc>
    UDR0 = data; //send the data
    125c:	e6 ec       	ldi	r30, 0xC6	; 198
    125e:	f0 e0       	ldi	r31, 0x00	; 0
    1260:	89 81       	ldd	r24, Y+1	; 0x01
    1262:	80 83       	st	Z, r24
    /*while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
	UDR0 = '\n';//send a new line just to be sure
	while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
	UDR0 = '\r';//send a new line just to be sure*/
}
    1264:	0f 90       	pop	r0
    1266:	cf 91       	pop	r28
    1268:	df 91       	pop	r29
    126a:	08 95       	ret

0000126c <uart_sendint16>:

void uart_sendint16(uint16_t data) {
    126c:	df 93       	push	r29
    126e:	cf 93       	push	r28
    1270:	00 d0       	rcall	.+0      	; 0x1272 <uart_sendint16+0x6>
    1272:	cd b7       	in	r28, 0x3d	; 61
    1274:	de b7       	in	r29, 0x3e	; 62
    1276:	9a 83       	std	Y+2, r25	; 0x02
    1278:	89 83       	std	Y+1, r24	; 0x01
    /*
    Use this to send a 16bit long piece of data
    */
    while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    127a:	e0 ec       	ldi	r30, 0xC0	; 192
    127c:	f0 e0       	ldi	r31, 0x00	; 0
    127e:	80 81       	ld	r24, Z
    1280:	88 2f       	mov	r24, r24
    1282:	90 e0       	ldi	r25, 0x00	; 0
    1284:	80 72       	andi	r24, 0x20	; 32
    1286:	90 70       	andi	r25, 0x00	; 0
    1288:	00 97       	sbiw	r24, 0x00	; 0
    128a:	b9 f3       	breq	.-18     	; 0x127a <uart_sendint16+0xe>
    UDR0 = data;//send the lower bits
    128c:	e6 ec       	ldi	r30, 0xC6	; 198
    128e:	f0 e0       	ldi	r31, 0x00	; 0
    1290:	89 81       	ldd	r24, Y+1	; 0x01
    1292:	80 83       	st	Z, r24
    while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    1294:	e0 ec       	ldi	r30, 0xC0	; 192
    1296:	f0 e0       	ldi	r31, 0x00	; 0
    1298:	80 81       	ld	r24, Z
    129a:	88 2f       	mov	r24, r24
    129c:	90 e0       	ldi	r25, 0x00	; 0
    129e:	80 72       	andi	r24, 0x20	; 32
    12a0:	90 70       	andi	r25, 0x00	; 0
    12a2:	00 97       	sbiw	r24, 0x00	; 0
    12a4:	b9 f3       	breq	.-18     	; 0x1294 <uart_sendint16+0x28>
    UDR0 = (data >> 8); //send the higher bits
    12a6:	e6 ec       	ldi	r30, 0xC6	; 198
    12a8:	f0 e0       	ldi	r31, 0x00	; 0
    12aa:	89 81       	ldd	r24, Y+1	; 0x01
    12ac:	9a 81       	ldd	r25, Y+2	; 0x02
    12ae:	89 2f       	mov	r24, r25
    12b0:	99 27       	eor	r25, r25
    12b2:	80 83       	st	Z, r24
    /*
    while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
	UDR0 = '\n';//send a new line just to be sure
	while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
	UDR0 = '\r';//send a new line just to be sure*/
}
    12b4:	0f 90       	pop	r0
    12b6:	0f 90       	pop	r0
    12b8:	cf 91       	pop	r28
    12ba:	df 91       	pop	r29
    12bc:	08 95       	ret

000012be <uart_sendchar>:

void uart_sendchar(char *data) {
    12be:	df 93       	push	r29
    12c0:	cf 93       	push	r28
    12c2:	00 d0       	rcall	.+0      	; 0x12c4 <uart_sendchar+0x6>
    12c4:	cd b7       	in	r28, 0x3d	; 61
    12c6:	de b7       	in	r29, 0x3e	; 62
    12c8:	9a 83       	std	Y+2, r25	; 0x02
    12ca:	89 83       	std	Y+1, r24	; 0x01
    12cc:	14 c0       	rjmp	.+40     	; 0x12f6 <uart_sendchar+0x38>
    /*
    Use this to send a string, it will split it up into individual parts
    send those parts, and then send the new line code
    */
    while (*data) {
        while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    12ce:	e0 ec       	ldi	r30, 0xC0	; 192
    12d0:	f0 e0       	ldi	r31, 0x00	; 0
    12d2:	80 81       	ld	r24, Z
    12d4:	88 2f       	mov	r24, r24
    12d6:	90 e0       	ldi	r25, 0x00	; 0
    12d8:	80 72       	andi	r24, 0x20	; 32
    12da:	90 70       	andi	r25, 0x00	; 0
    12dc:	00 97       	sbiw	r24, 0x00	; 0
    12de:	b9 f3       	breq	.-18     	; 0x12ce <uart_sendchar+0x10>
		UDR0 = *data; //goes through and splits the string into individual bits, sends them
    12e0:	a6 ec       	ldi	r26, 0xC6	; 198
    12e2:	b0 e0       	ldi	r27, 0x00	; 0
    12e4:	e9 81       	ldd	r30, Y+1	; 0x01
    12e6:	fa 81       	ldd	r31, Y+2	; 0x02
    12e8:	80 81       	ld	r24, Z
    12ea:	8c 93       	st	X, r24
		data += 1;//go to new bit in string
    12ec:	89 81       	ldd	r24, Y+1	; 0x01
    12ee:	9a 81       	ldd	r25, Y+2	; 0x02
    12f0:	01 96       	adiw	r24, 0x01	; 1
    12f2:	9a 83       	std	Y+2, r25	; 0x02
    12f4:	89 83       	std	Y+1, r24	; 0x01
void uart_sendchar(char *data) {
    /*
    Use this to send a string, it will split it up into individual parts
    send those parts, and then send the new line code
    */
    while (*data) {
    12f6:	e9 81       	ldd	r30, Y+1	; 0x01
    12f8:	fa 81       	ldd	r31, Y+2	; 0x02
    12fa:	80 81       	ld	r24, Z
    12fc:	88 23       	and	r24, r24
    12fe:	39 f7       	brne	.-50     	; 0x12ce <uart_sendchar+0x10>
	}/*
	while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
	UDR0 = '\n';//send a new line just to be sure
	while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
	UDR0 = '\r';//send a new line just to be sure*/
}
    1300:	0f 90       	pop	r0
    1302:	0f 90       	pop	r0
    1304:	cf 91       	pop	r28
    1306:	df 91       	pop	r29
    1308:	08 95       	ret

0000130a <uart_get>:

uint8_t uart_get(void) {
    130a:	df 93       	push	r29
    130c:	cf 93       	push	r28
    130e:	0f 92       	push	r0
    1310:	cd b7       	in	r28, 0x3d	; 61
    1312:	de b7       	in	r29, 0x3e	; 62
    /*
    gets data from the register that the interrupt stored it
    in coming data into, returning it to the calling function as 8 bit long data
    */
    UCSR0B |= (1<<RXCIE0);
    1314:	a1 ec       	ldi	r26, 0xC1	; 193
    1316:	b0 e0       	ldi	r27, 0x00	; 0
    1318:	e1 ec       	ldi	r30, 0xC1	; 193
    131a:	f0 e0       	ldi	r31, 0x00	; 0
    131c:	80 81       	ld	r24, Z
    131e:	80 68       	ori	r24, 0x80	; 128
    1320:	8c 93       	st	X, r24

    sei();
    1322:	78 94       	sei
	sleep_mode();
    1324:	a3 e5       	ldi	r26, 0x53	; 83
    1326:	b0 e0       	ldi	r27, 0x00	; 0
    1328:	e3 e5       	ldi	r30, 0x53	; 83
    132a:	f0 e0       	ldi	r31, 0x00	; 0
    132c:	80 81       	ld	r24, Z
    132e:	81 60       	ori	r24, 0x01	; 1
    1330:	8c 93       	st	X, r24
    1332:	88 95       	sleep
    1334:	a3 e5       	ldi	r26, 0x53	; 83
    1336:	b0 e0       	ldi	r27, 0x00	; 0
    1338:	e3 e5       	ldi	r30, 0x53	; 83
    133a:	f0 e0       	ldi	r31, 0x00	; 0
    133c:	80 81       	ld	r24, Z
    133e:	8e 7f       	andi	r24, 0xFE	; 254
    1340:	8c 93       	st	X, r24
	cli();
    1342:	f8 94       	cli
	uint8_t b;
    if(read_spot == 0)
    1344:	80 91 13 01 	lds	r24, 0x0113
    1348:	90 91 14 01 	lds	r25, 0x0114
    134c:	00 97       	sbiw	r24, 0x00	; 0
    134e:	21 f4       	brne	.+8      	; 0x1358 <uart_get+0x4e>
		b = input_buffer[sizeof(input_buffer) - 1];
    1350:	80 91 d6 03 	lds	r24, 0x03D6
    1354:	89 83       	std	Y+1, r24	; 0x01
    1356:	0a c0       	rjmp	.+20     	; 0x136c <uart_get+0x62>
	else
		b = input_buffer[read_spot - 1];
    1358:	80 91 13 01 	lds	r24, 0x0113
    135c:	90 91 14 01 	lds	r25, 0x0114
    1360:	01 97       	sbiw	r24, 0x01	; 1
    1362:	fc 01       	movw	r30, r24
    1364:	e5 5e       	subi	r30, 0xE5	; 229
    1366:	fe 4f       	sbci	r31, 0xFE	; 254
    1368:	80 81       	ld	r24, Z
    136a:	89 83       	std	Y+1, r24	; 0x01
    if(b == '\r')
    136c:	89 81       	ldd	r24, Y+1	; 0x01
    136e:	8d 30       	cpi	r24, 0x0D	; 13
    1370:	11 f4       	brne	.+4      	; 0x1376 <uart_get+0x6c>
        b = '\n';
    1372:	8a e0       	ldi	r24, 0x0A	; 10
    1374:	89 83       	std	Y+1, r24	; 0x01
	return b;
    1376:	89 81       	ldd	r24, Y+1	; 0x01
}
    1378:	0f 90       	pop	r0
    137a:	cf 91       	pop	r28
    137c:	df 91       	pop	r29
    137e:	08 95       	ret

00001380 <__vector_18>:

ISR(USART_RX_vect) {//sets up the interrupt to recieve any data coming in
    1380:	1f 92       	push	r1
    1382:	0f 92       	push	r0
    1384:	0f b6       	in	r0, 0x3f	; 63
    1386:	0f 92       	push	r0
    1388:	11 24       	eor	r1, r1
    138a:	2f 93       	push	r18
    138c:	3f 93       	push	r19
    138e:	8f 93       	push	r24
    1390:	9f 93       	push	r25
    1392:	ef 93       	push	r30
    1394:	ff 93       	push	r31
    1396:	df 93       	push	r29
    1398:	cf 93       	push	r28
    139a:	cd b7       	in	r28, 0x3d	; 61
    139c:	de b7       	in	r29, 0x3e	; 62
	input_buffer[read_spot] = UDR0;
    139e:	20 91 13 01 	lds	r18, 0x0113
    13a2:	30 91 14 01 	lds	r19, 0x0114
    13a6:	e6 ec       	ldi	r30, 0xC6	; 198
    13a8:	f0 e0       	ldi	r31, 0x00	; 0
    13aa:	80 81       	ld	r24, Z
    13ac:	f9 01       	movw	r30, r18
    13ae:	e5 5e       	subi	r30, 0xE5	; 229
    13b0:	fe 4f       	sbci	r31, 0xFE	; 254
    13b2:	80 83       	st	Z, r24
	read_spot++;//and "exports" if you will the data to a variable outside of the register
    13b4:	80 91 13 01 	lds	r24, 0x0113
    13b8:	90 91 14 01 	lds	r25, 0x0114
    13bc:	01 96       	adiw	r24, 0x01	; 1
    13be:	90 93 14 01 	sts	0x0114, r25
    13c2:	80 93 13 01 	sts	0x0113, r24
	//until the main program has time to read it. makes sure data isn't lost as much
	if(read_spot == BUFF_LEN) read_spot = 0;
    13c6:	80 91 13 01 	lds	r24, 0x0113
    13ca:	90 91 14 01 	lds	r25, 0x0114
    13ce:	22 e0       	ldi	r18, 0x02	; 2
    13d0:	8c 3b       	cpi	r24, 0xBC	; 188
    13d2:	92 07       	cpc	r25, r18
    13d4:	21 f4       	brne	.+8      	; 0x13de <__vector_18+0x5e>
    13d6:	10 92 14 01 	sts	0x0114, r1
    13da:	10 92 13 01 	sts	0x0113, r1
}
    13de:	cf 91       	pop	r28
    13e0:	df 91       	pop	r29
    13e2:	ff 91       	pop	r31
    13e4:	ef 91       	pop	r30
    13e6:	9f 91       	pop	r25
    13e8:	8f 91       	pop	r24
    13ea:	3f 91       	pop	r19
    13ec:	2f 91       	pop	r18
    13ee:	0f 90       	pop	r0
    13f0:	0f be       	out	0x3f, r0	; 63
    13f2:	0f 90       	pop	r0
    13f4:	1f 90       	pop	r1
    13f6:	18 95       	reti

000013f8 <__fixunssfsi>:
    13f8:	ef 92       	push	r14
    13fa:	ff 92       	push	r15
    13fc:	0f 93       	push	r16
    13fe:	1f 93       	push	r17
    1400:	7b 01       	movw	r14, r22
    1402:	8c 01       	movw	r16, r24
    1404:	20 e0       	ldi	r18, 0x00	; 0
    1406:	30 e0       	ldi	r19, 0x00	; 0
    1408:	40 e0       	ldi	r20, 0x00	; 0
    140a:	5f e4       	ldi	r21, 0x4F	; 79
    140c:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <__gesf2>
    1410:	88 23       	and	r24, r24
    1412:	8c f0       	brlt	.+34     	; 0x1436 <__fixunssfsi+0x3e>
    1414:	c8 01       	movw	r24, r16
    1416:	b7 01       	movw	r22, r14
    1418:	20 e0       	ldi	r18, 0x00	; 0
    141a:	30 e0       	ldi	r19, 0x00	; 0
    141c:	40 e0       	ldi	r20, 0x00	; 0
    141e:	5f e4       	ldi	r21, 0x4F	; 79
    1420:	0e 94 74 0b 	call	0x16e8	; 0x16e8 <__subsf3>
    1424:	0e 94 5c 0d 	call	0x1ab8	; 0x1ab8 <__fixsfsi>
    1428:	9b 01       	movw	r18, r22
    142a:	ac 01       	movw	r20, r24
    142c:	20 50       	subi	r18, 0x00	; 0
    142e:	30 40       	sbci	r19, 0x00	; 0
    1430:	40 40       	sbci	r20, 0x00	; 0
    1432:	50 48       	sbci	r21, 0x80	; 128
    1434:	06 c0       	rjmp	.+12     	; 0x1442 <__fixunssfsi+0x4a>
    1436:	c8 01       	movw	r24, r16
    1438:	b7 01       	movw	r22, r14
    143a:	0e 94 5c 0d 	call	0x1ab8	; 0x1ab8 <__fixsfsi>
    143e:	9b 01       	movw	r18, r22
    1440:	ac 01       	movw	r20, r24
    1442:	b9 01       	movw	r22, r18
    1444:	ca 01       	movw	r24, r20
    1446:	1f 91       	pop	r17
    1448:	0f 91       	pop	r16
    144a:	ff 90       	pop	r15
    144c:	ef 90       	pop	r14
    144e:	08 95       	ret

00001450 <_fpadd_parts>:
    1450:	a0 e0       	ldi	r26, 0x00	; 0
    1452:	b0 e0       	ldi	r27, 0x00	; 0
    1454:	ee e2       	ldi	r30, 0x2E	; 46
    1456:	fa e0       	ldi	r31, 0x0A	; 10
    1458:	0c 94 6a 0f 	jmp	0x1ed4	; 0x1ed4 <__prologue_saves__>
    145c:	dc 01       	movw	r26, r24
    145e:	2b 01       	movw	r4, r22
    1460:	fa 01       	movw	r30, r20
    1462:	9c 91       	ld	r25, X
    1464:	92 30       	cpi	r25, 0x02	; 2
    1466:	08 f4       	brcc	.+2      	; 0x146a <_fpadd_parts+0x1a>
    1468:	39 c1       	rjmp	.+626    	; 0x16dc <_fpadd_parts+0x28c>
    146a:	eb 01       	movw	r28, r22
    146c:	88 81       	ld	r24, Y
    146e:	82 30       	cpi	r24, 0x02	; 2
    1470:	08 f4       	brcc	.+2      	; 0x1474 <_fpadd_parts+0x24>
    1472:	33 c1       	rjmp	.+614    	; 0x16da <_fpadd_parts+0x28a>
    1474:	94 30       	cpi	r25, 0x04	; 4
    1476:	69 f4       	brne	.+26     	; 0x1492 <_fpadd_parts+0x42>
    1478:	84 30       	cpi	r24, 0x04	; 4
    147a:	09 f0       	breq	.+2      	; 0x147e <_fpadd_parts+0x2e>
    147c:	2f c1       	rjmp	.+606    	; 0x16dc <_fpadd_parts+0x28c>
    147e:	11 96       	adiw	r26, 0x01	; 1
    1480:	9c 91       	ld	r25, X
    1482:	11 97       	sbiw	r26, 0x01	; 1
    1484:	89 81       	ldd	r24, Y+1	; 0x01
    1486:	98 17       	cp	r25, r24
    1488:	09 f4       	brne	.+2      	; 0x148c <_fpadd_parts+0x3c>
    148a:	28 c1       	rjmp	.+592    	; 0x16dc <_fpadd_parts+0x28c>
    148c:	a6 e0       	ldi	r26, 0x06	; 6
    148e:	b1 e0       	ldi	r27, 0x01	; 1
    1490:	25 c1       	rjmp	.+586    	; 0x16dc <_fpadd_parts+0x28c>
    1492:	84 30       	cpi	r24, 0x04	; 4
    1494:	09 f4       	brne	.+2      	; 0x1498 <_fpadd_parts+0x48>
    1496:	21 c1       	rjmp	.+578    	; 0x16da <_fpadd_parts+0x28a>
    1498:	82 30       	cpi	r24, 0x02	; 2
    149a:	a9 f4       	brne	.+42     	; 0x14c6 <_fpadd_parts+0x76>
    149c:	92 30       	cpi	r25, 0x02	; 2
    149e:	09 f0       	breq	.+2      	; 0x14a2 <_fpadd_parts+0x52>
    14a0:	1d c1       	rjmp	.+570    	; 0x16dc <_fpadd_parts+0x28c>
    14a2:	9a 01       	movw	r18, r20
    14a4:	ad 01       	movw	r20, r26
    14a6:	88 e0       	ldi	r24, 0x08	; 8
    14a8:	ea 01       	movw	r28, r20
    14aa:	09 90       	ld	r0, Y+
    14ac:	ae 01       	movw	r20, r28
    14ae:	e9 01       	movw	r28, r18
    14b0:	09 92       	st	Y+, r0
    14b2:	9e 01       	movw	r18, r28
    14b4:	81 50       	subi	r24, 0x01	; 1
    14b6:	c1 f7       	brne	.-16     	; 0x14a8 <_fpadd_parts+0x58>
    14b8:	e2 01       	movw	r28, r4
    14ba:	89 81       	ldd	r24, Y+1	; 0x01
    14bc:	11 96       	adiw	r26, 0x01	; 1
    14be:	9c 91       	ld	r25, X
    14c0:	89 23       	and	r24, r25
    14c2:	81 83       	std	Z+1, r24	; 0x01
    14c4:	08 c1       	rjmp	.+528    	; 0x16d6 <_fpadd_parts+0x286>
    14c6:	92 30       	cpi	r25, 0x02	; 2
    14c8:	09 f4       	brne	.+2      	; 0x14cc <_fpadd_parts+0x7c>
    14ca:	07 c1       	rjmp	.+526    	; 0x16da <_fpadd_parts+0x28a>
    14cc:	12 96       	adiw	r26, 0x02	; 2
    14ce:	2d 90       	ld	r2, X+
    14d0:	3c 90       	ld	r3, X
    14d2:	13 97       	sbiw	r26, 0x03	; 3
    14d4:	eb 01       	movw	r28, r22
    14d6:	8a 81       	ldd	r24, Y+2	; 0x02
    14d8:	9b 81       	ldd	r25, Y+3	; 0x03
    14da:	14 96       	adiw	r26, 0x04	; 4
    14dc:	ad 90       	ld	r10, X+
    14de:	bd 90       	ld	r11, X+
    14e0:	cd 90       	ld	r12, X+
    14e2:	dc 90       	ld	r13, X
    14e4:	17 97       	sbiw	r26, 0x07	; 7
    14e6:	ec 80       	ldd	r14, Y+4	; 0x04
    14e8:	fd 80       	ldd	r15, Y+5	; 0x05
    14ea:	0e 81       	ldd	r16, Y+6	; 0x06
    14ec:	1f 81       	ldd	r17, Y+7	; 0x07
    14ee:	91 01       	movw	r18, r2
    14f0:	28 1b       	sub	r18, r24
    14f2:	39 0b       	sbc	r19, r25
    14f4:	b9 01       	movw	r22, r18
    14f6:	37 ff       	sbrs	r19, 7
    14f8:	04 c0       	rjmp	.+8      	; 0x1502 <_fpadd_parts+0xb2>
    14fa:	66 27       	eor	r22, r22
    14fc:	77 27       	eor	r23, r23
    14fe:	62 1b       	sub	r22, r18
    1500:	73 0b       	sbc	r23, r19
    1502:	60 32       	cpi	r22, 0x20	; 32
    1504:	71 05       	cpc	r23, r1
    1506:	0c f0       	brlt	.+2      	; 0x150a <_fpadd_parts+0xba>
    1508:	61 c0       	rjmp	.+194    	; 0x15cc <_fpadd_parts+0x17c>
    150a:	12 16       	cp	r1, r18
    150c:	13 06       	cpc	r1, r19
    150e:	6c f5       	brge	.+90     	; 0x156a <_fpadd_parts+0x11a>
    1510:	37 01       	movw	r6, r14
    1512:	48 01       	movw	r8, r16
    1514:	06 2e       	mov	r0, r22
    1516:	04 c0       	rjmp	.+8      	; 0x1520 <_fpadd_parts+0xd0>
    1518:	96 94       	lsr	r9
    151a:	87 94       	ror	r8
    151c:	77 94       	ror	r7
    151e:	67 94       	ror	r6
    1520:	0a 94       	dec	r0
    1522:	d2 f7       	brpl	.-12     	; 0x1518 <_fpadd_parts+0xc8>
    1524:	21 e0       	ldi	r18, 0x01	; 1
    1526:	30 e0       	ldi	r19, 0x00	; 0
    1528:	40 e0       	ldi	r20, 0x00	; 0
    152a:	50 e0       	ldi	r21, 0x00	; 0
    152c:	04 c0       	rjmp	.+8      	; 0x1536 <_fpadd_parts+0xe6>
    152e:	22 0f       	add	r18, r18
    1530:	33 1f       	adc	r19, r19
    1532:	44 1f       	adc	r20, r20
    1534:	55 1f       	adc	r21, r21
    1536:	6a 95       	dec	r22
    1538:	d2 f7       	brpl	.-12     	; 0x152e <_fpadd_parts+0xde>
    153a:	21 50       	subi	r18, 0x01	; 1
    153c:	30 40       	sbci	r19, 0x00	; 0
    153e:	40 40       	sbci	r20, 0x00	; 0
    1540:	50 40       	sbci	r21, 0x00	; 0
    1542:	2e 21       	and	r18, r14
    1544:	3f 21       	and	r19, r15
    1546:	40 23       	and	r20, r16
    1548:	51 23       	and	r21, r17
    154a:	21 15       	cp	r18, r1
    154c:	31 05       	cpc	r19, r1
    154e:	41 05       	cpc	r20, r1
    1550:	51 05       	cpc	r21, r1
    1552:	21 f0       	breq	.+8      	; 0x155c <_fpadd_parts+0x10c>
    1554:	21 e0       	ldi	r18, 0x01	; 1
    1556:	30 e0       	ldi	r19, 0x00	; 0
    1558:	40 e0       	ldi	r20, 0x00	; 0
    155a:	50 e0       	ldi	r21, 0x00	; 0
    155c:	79 01       	movw	r14, r18
    155e:	8a 01       	movw	r16, r20
    1560:	e6 28       	or	r14, r6
    1562:	f7 28       	or	r15, r7
    1564:	08 29       	or	r16, r8
    1566:	19 29       	or	r17, r9
    1568:	3c c0       	rjmp	.+120    	; 0x15e2 <_fpadd_parts+0x192>
    156a:	23 2b       	or	r18, r19
    156c:	d1 f1       	breq	.+116    	; 0x15e2 <_fpadd_parts+0x192>
    156e:	26 0e       	add	r2, r22
    1570:	37 1e       	adc	r3, r23
    1572:	35 01       	movw	r6, r10
    1574:	46 01       	movw	r8, r12
    1576:	06 2e       	mov	r0, r22
    1578:	04 c0       	rjmp	.+8      	; 0x1582 <_fpadd_parts+0x132>
    157a:	96 94       	lsr	r9
    157c:	87 94       	ror	r8
    157e:	77 94       	ror	r7
    1580:	67 94       	ror	r6
    1582:	0a 94       	dec	r0
    1584:	d2 f7       	brpl	.-12     	; 0x157a <_fpadd_parts+0x12a>
    1586:	21 e0       	ldi	r18, 0x01	; 1
    1588:	30 e0       	ldi	r19, 0x00	; 0
    158a:	40 e0       	ldi	r20, 0x00	; 0
    158c:	50 e0       	ldi	r21, 0x00	; 0
    158e:	04 c0       	rjmp	.+8      	; 0x1598 <_fpadd_parts+0x148>
    1590:	22 0f       	add	r18, r18
    1592:	33 1f       	adc	r19, r19
    1594:	44 1f       	adc	r20, r20
    1596:	55 1f       	adc	r21, r21
    1598:	6a 95       	dec	r22
    159a:	d2 f7       	brpl	.-12     	; 0x1590 <_fpadd_parts+0x140>
    159c:	21 50       	subi	r18, 0x01	; 1
    159e:	30 40       	sbci	r19, 0x00	; 0
    15a0:	40 40       	sbci	r20, 0x00	; 0
    15a2:	50 40       	sbci	r21, 0x00	; 0
    15a4:	2a 21       	and	r18, r10
    15a6:	3b 21       	and	r19, r11
    15a8:	4c 21       	and	r20, r12
    15aa:	5d 21       	and	r21, r13
    15ac:	21 15       	cp	r18, r1
    15ae:	31 05       	cpc	r19, r1
    15b0:	41 05       	cpc	r20, r1
    15b2:	51 05       	cpc	r21, r1
    15b4:	21 f0       	breq	.+8      	; 0x15be <_fpadd_parts+0x16e>
    15b6:	21 e0       	ldi	r18, 0x01	; 1
    15b8:	30 e0       	ldi	r19, 0x00	; 0
    15ba:	40 e0       	ldi	r20, 0x00	; 0
    15bc:	50 e0       	ldi	r21, 0x00	; 0
    15be:	59 01       	movw	r10, r18
    15c0:	6a 01       	movw	r12, r20
    15c2:	a6 28       	or	r10, r6
    15c4:	b7 28       	or	r11, r7
    15c6:	c8 28       	or	r12, r8
    15c8:	d9 28       	or	r13, r9
    15ca:	0b c0       	rjmp	.+22     	; 0x15e2 <_fpadd_parts+0x192>
    15cc:	82 15       	cp	r24, r2
    15ce:	93 05       	cpc	r25, r3
    15d0:	2c f0       	brlt	.+10     	; 0x15dc <_fpadd_parts+0x18c>
    15d2:	1c 01       	movw	r2, r24
    15d4:	aa 24       	eor	r10, r10
    15d6:	bb 24       	eor	r11, r11
    15d8:	65 01       	movw	r12, r10
    15da:	03 c0       	rjmp	.+6      	; 0x15e2 <_fpadd_parts+0x192>
    15dc:	ee 24       	eor	r14, r14
    15de:	ff 24       	eor	r15, r15
    15e0:	87 01       	movw	r16, r14
    15e2:	11 96       	adiw	r26, 0x01	; 1
    15e4:	9c 91       	ld	r25, X
    15e6:	d2 01       	movw	r26, r4
    15e8:	11 96       	adiw	r26, 0x01	; 1
    15ea:	8c 91       	ld	r24, X
    15ec:	98 17       	cp	r25, r24
    15ee:	09 f4       	brne	.+2      	; 0x15f2 <_fpadd_parts+0x1a2>
    15f0:	45 c0       	rjmp	.+138    	; 0x167c <_fpadd_parts+0x22c>
    15f2:	99 23       	and	r25, r25
    15f4:	39 f0       	breq	.+14     	; 0x1604 <_fpadd_parts+0x1b4>
    15f6:	a8 01       	movw	r20, r16
    15f8:	97 01       	movw	r18, r14
    15fa:	2a 19       	sub	r18, r10
    15fc:	3b 09       	sbc	r19, r11
    15fe:	4c 09       	sbc	r20, r12
    1600:	5d 09       	sbc	r21, r13
    1602:	06 c0       	rjmp	.+12     	; 0x1610 <_fpadd_parts+0x1c0>
    1604:	a6 01       	movw	r20, r12
    1606:	95 01       	movw	r18, r10
    1608:	2e 19       	sub	r18, r14
    160a:	3f 09       	sbc	r19, r15
    160c:	40 0b       	sbc	r20, r16
    160e:	51 0b       	sbc	r21, r17
    1610:	57 fd       	sbrc	r21, 7
    1612:	08 c0       	rjmp	.+16     	; 0x1624 <_fpadd_parts+0x1d4>
    1614:	11 82       	std	Z+1, r1	; 0x01
    1616:	33 82       	std	Z+3, r3	; 0x03
    1618:	22 82       	std	Z+2, r2	; 0x02
    161a:	24 83       	std	Z+4, r18	; 0x04
    161c:	35 83       	std	Z+5, r19	; 0x05
    161e:	46 83       	std	Z+6, r20	; 0x06
    1620:	57 83       	std	Z+7, r21	; 0x07
    1622:	1d c0       	rjmp	.+58     	; 0x165e <_fpadd_parts+0x20e>
    1624:	81 e0       	ldi	r24, 0x01	; 1
    1626:	81 83       	std	Z+1, r24	; 0x01
    1628:	33 82       	std	Z+3, r3	; 0x03
    162a:	22 82       	std	Z+2, r2	; 0x02
    162c:	88 27       	eor	r24, r24
    162e:	99 27       	eor	r25, r25
    1630:	dc 01       	movw	r26, r24
    1632:	82 1b       	sub	r24, r18
    1634:	93 0b       	sbc	r25, r19
    1636:	a4 0b       	sbc	r26, r20
    1638:	b5 0b       	sbc	r27, r21
    163a:	84 83       	std	Z+4, r24	; 0x04
    163c:	95 83       	std	Z+5, r25	; 0x05
    163e:	a6 83       	std	Z+6, r26	; 0x06
    1640:	b7 83       	std	Z+7, r27	; 0x07
    1642:	0d c0       	rjmp	.+26     	; 0x165e <_fpadd_parts+0x20e>
    1644:	22 0f       	add	r18, r18
    1646:	33 1f       	adc	r19, r19
    1648:	44 1f       	adc	r20, r20
    164a:	55 1f       	adc	r21, r21
    164c:	24 83       	std	Z+4, r18	; 0x04
    164e:	35 83       	std	Z+5, r19	; 0x05
    1650:	46 83       	std	Z+6, r20	; 0x06
    1652:	57 83       	std	Z+7, r21	; 0x07
    1654:	82 81       	ldd	r24, Z+2	; 0x02
    1656:	93 81       	ldd	r25, Z+3	; 0x03
    1658:	01 97       	sbiw	r24, 0x01	; 1
    165a:	93 83       	std	Z+3, r25	; 0x03
    165c:	82 83       	std	Z+2, r24	; 0x02
    165e:	24 81       	ldd	r18, Z+4	; 0x04
    1660:	35 81       	ldd	r19, Z+5	; 0x05
    1662:	46 81       	ldd	r20, Z+6	; 0x06
    1664:	57 81       	ldd	r21, Z+7	; 0x07
    1666:	da 01       	movw	r26, r20
    1668:	c9 01       	movw	r24, r18
    166a:	01 97       	sbiw	r24, 0x01	; 1
    166c:	a1 09       	sbc	r26, r1
    166e:	b1 09       	sbc	r27, r1
    1670:	8f 5f       	subi	r24, 0xFF	; 255
    1672:	9f 4f       	sbci	r25, 0xFF	; 255
    1674:	af 4f       	sbci	r26, 0xFF	; 255
    1676:	bf 43       	sbci	r27, 0x3F	; 63
    1678:	28 f3       	brcs	.-54     	; 0x1644 <_fpadd_parts+0x1f4>
    167a:	0b c0       	rjmp	.+22     	; 0x1692 <_fpadd_parts+0x242>
    167c:	91 83       	std	Z+1, r25	; 0x01
    167e:	33 82       	std	Z+3, r3	; 0x03
    1680:	22 82       	std	Z+2, r2	; 0x02
    1682:	ea 0c       	add	r14, r10
    1684:	fb 1c       	adc	r15, r11
    1686:	0c 1d       	adc	r16, r12
    1688:	1d 1d       	adc	r17, r13
    168a:	e4 82       	std	Z+4, r14	; 0x04
    168c:	f5 82       	std	Z+5, r15	; 0x05
    168e:	06 83       	std	Z+6, r16	; 0x06
    1690:	17 83       	std	Z+7, r17	; 0x07
    1692:	83 e0       	ldi	r24, 0x03	; 3
    1694:	80 83       	st	Z, r24
    1696:	24 81       	ldd	r18, Z+4	; 0x04
    1698:	35 81       	ldd	r19, Z+5	; 0x05
    169a:	46 81       	ldd	r20, Z+6	; 0x06
    169c:	57 81       	ldd	r21, Z+7	; 0x07
    169e:	57 ff       	sbrs	r21, 7
    16a0:	1a c0       	rjmp	.+52     	; 0x16d6 <_fpadd_parts+0x286>
    16a2:	c9 01       	movw	r24, r18
    16a4:	aa 27       	eor	r26, r26
    16a6:	97 fd       	sbrc	r25, 7
    16a8:	a0 95       	com	r26
    16aa:	ba 2f       	mov	r27, r26
    16ac:	81 70       	andi	r24, 0x01	; 1
    16ae:	90 70       	andi	r25, 0x00	; 0
    16b0:	a0 70       	andi	r26, 0x00	; 0
    16b2:	b0 70       	andi	r27, 0x00	; 0
    16b4:	56 95       	lsr	r21
    16b6:	47 95       	ror	r20
    16b8:	37 95       	ror	r19
    16ba:	27 95       	ror	r18
    16bc:	82 2b       	or	r24, r18
    16be:	93 2b       	or	r25, r19
    16c0:	a4 2b       	or	r26, r20
    16c2:	b5 2b       	or	r27, r21
    16c4:	84 83       	std	Z+4, r24	; 0x04
    16c6:	95 83       	std	Z+5, r25	; 0x05
    16c8:	a6 83       	std	Z+6, r26	; 0x06
    16ca:	b7 83       	std	Z+7, r27	; 0x07
    16cc:	82 81       	ldd	r24, Z+2	; 0x02
    16ce:	93 81       	ldd	r25, Z+3	; 0x03
    16d0:	01 96       	adiw	r24, 0x01	; 1
    16d2:	93 83       	std	Z+3, r25	; 0x03
    16d4:	82 83       	std	Z+2, r24	; 0x02
    16d6:	df 01       	movw	r26, r30
    16d8:	01 c0       	rjmp	.+2      	; 0x16dc <_fpadd_parts+0x28c>
    16da:	d2 01       	movw	r26, r4
    16dc:	cd 01       	movw	r24, r26
    16de:	cd b7       	in	r28, 0x3d	; 61
    16e0:	de b7       	in	r29, 0x3e	; 62
    16e2:	e2 e1       	ldi	r30, 0x12	; 18
    16e4:	0c 94 86 0f 	jmp	0x1f0c	; 0x1f0c <__epilogue_restores__>

000016e8 <__subsf3>:
    16e8:	a0 e2       	ldi	r26, 0x20	; 32
    16ea:	b0 e0       	ldi	r27, 0x00	; 0
    16ec:	ea e7       	ldi	r30, 0x7A	; 122
    16ee:	fb e0       	ldi	r31, 0x0B	; 11
    16f0:	0c 94 76 0f 	jmp	0x1eec	; 0x1eec <__prologue_saves__+0x18>
    16f4:	69 83       	std	Y+1, r22	; 0x01
    16f6:	7a 83       	std	Y+2, r23	; 0x02
    16f8:	8b 83       	std	Y+3, r24	; 0x03
    16fa:	9c 83       	std	Y+4, r25	; 0x04
    16fc:	2d 83       	std	Y+5, r18	; 0x05
    16fe:	3e 83       	std	Y+6, r19	; 0x06
    1700:	4f 83       	std	Y+7, r20	; 0x07
    1702:	58 87       	std	Y+8, r21	; 0x08
    1704:	e9 e0       	ldi	r30, 0x09	; 9
    1706:	ee 2e       	mov	r14, r30
    1708:	f1 2c       	mov	r15, r1
    170a:	ec 0e       	add	r14, r28
    170c:	fd 1e       	adc	r15, r29
    170e:	ce 01       	movw	r24, r28
    1710:	01 96       	adiw	r24, 0x01	; 1
    1712:	b7 01       	movw	r22, r14
    1714:	0e 94 85 0e 	call	0x1d0a	; 0x1d0a <__unpack_f>
    1718:	8e 01       	movw	r16, r28
    171a:	0f 5e       	subi	r16, 0xEF	; 239
    171c:	1f 4f       	sbci	r17, 0xFF	; 255
    171e:	ce 01       	movw	r24, r28
    1720:	05 96       	adiw	r24, 0x05	; 5
    1722:	b8 01       	movw	r22, r16
    1724:	0e 94 85 0e 	call	0x1d0a	; 0x1d0a <__unpack_f>
    1728:	8a 89       	ldd	r24, Y+18	; 0x12
    172a:	91 e0       	ldi	r25, 0x01	; 1
    172c:	89 27       	eor	r24, r25
    172e:	8a 8b       	std	Y+18, r24	; 0x12
    1730:	c7 01       	movw	r24, r14
    1732:	b8 01       	movw	r22, r16
    1734:	ae 01       	movw	r20, r28
    1736:	47 5e       	subi	r20, 0xE7	; 231
    1738:	5f 4f       	sbci	r21, 0xFF	; 255
    173a:	0e 94 28 0a 	call	0x1450	; 0x1450 <_fpadd_parts>
    173e:	0e 94 b0 0d 	call	0x1b60	; 0x1b60 <__pack_f>
    1742:	a0 96       	adiw	r28, 0x20	; 32
    1744:	e6 e0       	ldi	r30, 0x06	; 6
    1746:	0c 94 92 0f 	jmp	0x1f24	; 0x1f24 <__epilogue_restores__+0x18>

0000174a <__addsf3>:
    174a:	a0 e2       	ldi	r26, 0x20	; 32
    174c:	b0 e0       	ldi	r27, 0x00	; 0
    174e:	eb ea       	ldi	r30, 0xAB	; 171
    1750:	fb e0       	ldi	r31, 0x0B	; 11
    1752:	0c 94 76 0f 	jmp	0x1eec	; 0x1eec <__prologue_saves__+0x18>
    1756:	69 83       	std	Y+1, r22	; 0x01
    1758:	7a 83       	std	Y+2, r23	; 0x02
    175a:	8b 83       	std	Y+3, r24	; 0x03
    175c:	9c 83       	std	Y+4, r25	; 0x04
    175e:	2d 83       	std	Y+5, r18	; 0x05
    1760:	3e 83       	std	Y+6, r19	; 0x06
    1762:	4f 83       	std	Y+7, r20	; 0x07
    1764:	58 87       	std	Y+8, r21	; 0x08
    1766:	f9 e0       	ldi	r31, 0x09	; 9
    1768:	ef 2e       	mov	r14, r31
    176a:	f1 2c       	mov	r15, r1
    176c:	ec 0e       	add	r14, r28
    176e:	fd 1e       	adc	r15, r29
    1770:	ce 01       	movw	r24, r28
    1772:	01 96       	adiw	r24, 0x01	; 1
    1774:	b7 01       	movw	r22, r14
    1776:	0e 94 85 0e 	call	0x1d0a	; 0x1d0a <__unpack_f>
    177a:	8e 01       	movw	r16, r28
    177c:	0f 5e       	subi	r16, 0xEF	; 239
    177e:	1f 4f       	sbci	r17, 0xFF	; 255
    1780:	ce 01       	movw	r24, r28
    1782:	05 96       	adiw	r24, 0x05	; 5
    1784:	b8 01       	movw	r22, r16
    1786:	0e 94 85 0e 	call	0x1d0a	; 0x1d0a <__unpack_f>
    178a:	c7 01       	movw	r24, r14
    178c:	b8 01       	movw	r22, r16
    178e:	ae 01       	movw	r20, r28
    1790:	47 5e       	subi	r20, 0xE7	; 231
    1792:	5f 4f       	sbci	r21, 0xFF	; 255
    1794:	0e 94 28 0a 	call	0x1450	; 0x1450 <_fpadd_parts>
    1798:	0e 94 b0 0d 	call	0x1b60	; 0x1b60 <__pack_f>
    179c:	a0 96       	adiw	r28, 0x20	; 32
    179e:	e6 e0       	ldi	r30, 0x06	; 6
    17a0:	0c 94 92 0f 	jmp	0x1f24	; 0x1f24 <__epilogue_restores__+0x18>

000017a4 <__mulsf3>:
    17a4:	a0 e2       	ldi	r26, 0x20	; 32
    17a6:	b0 e0       	ldi	r27, 0x00	; 0
    17a8:	e8 ed       	ldi	r30, 0xD8	; 216
    17aa:	fb e0       	ldi	r31, 0x0B	; 11
    17ac:	0c 94 6a 0f 	jmp	0x1ed4	; 0x1ed4 <__prologue_saves__>
    17b0:	69 83       	std	Y+1, r22	; 0x01
    17b2:	7a 83       	std	Y+2, r23	; 0x02
    17b4:	8b 83       	std	Y+3, r24	; 0x03
    17b6:	9c 83       	std	Y+4, r25	; 0x04
    17b8:	2d 83       	std	Y+5, r18	; 0x05
    17ba:	3e 83       	std	Y+6, r19	; 0x06
    17bc:	4f 83       	std	Y+7, r20	; 0x07
    17be:	58 87       	std	Y+8, r21	; 0x08
    17c0:	ce 01       	movw	r24, r28
    17c2:	01 96       	adiw	r24, 0x01	; 1
    17c4:	be 01       	movw	r22, r28
    17c6:	67 5f       	subi	r22, 0xF7	; 247
    17c8:	7f 4f       	sbci	r23, 0xFF	; 255
    17ca:	0e 94 85 0e 	call	0x1d0a	; 0x1d0a <__unpack_f>
    17ce:	ce 01       	movw	r24, r28
    17d0:	05 96       	adiw	r24, 0x05	; 5
    17d2:	be 01       	movw	r22, r28
    17d4:	6f 5e       	subi	r22, 0xEF	; 239
    17d6:	7f 4f       	sbci	r23, 0xFF	; 255
    17d8:	0e 94 85 0e 	call	0x1d0a	; 0x1d0a <__unpack_f>
    17dc:	99 85       	ldd	r25, Y+9	; 0x09
    17de:	92 30       	cpi	r25, 0x02	; 2
    17e0:	88 f0       	brcs	.+34     	; 0x1804 <__mulsf3+0x60>
    17e2:	89 89       	ldd	r24, Y+17	; 0x11
    17e4:	82 30       	cpi	r24, 0x02	; 2
    17e6:	c8 f0       	brcs	.+50     	; 0x181a <__mulsf3+0x76>
    17e8:	94 30       	cpi	r25, 0x04	; 4
    17ea:	19 f4       	brne	.+6      	; 0x17f2 <__mulsf3+0x4e>
    17ec:	82 30       	cpi	r24, 0x02	; 2
    17ee:	51 f4       	brne	.+20     	; 0x1804 <__mulsf3+0x60>
    17f0:	04 c0       	rjmp	.+8      	; 0x17fa <__mulsf3+0x56>
    17f2:	84 30       	cpi	r24, 0x04	; 4
    17f4:	29 f4       	brne	.+10     	; 0x1800 <__mulsf3+0x5c>
    17f6:	92 30       	cpi	r25, 0x02	; 2
    17f8:	81 f4       	brne	.+32     	; 0x181a <__mulsf3+0x76>
    17fa:	86 e0       	ldi	r24, 0x06	; 6
    17fc:	91 e0       	ldi	r25, 0x01	; 1
    17fe:	c6 c0       	rjmp	.+396    	; 0x198c <__mulsf3+0x1e8>
    1800:	92 30       	cpi	r25, 0x02	; 2
    1802:	49 f4       	brne	.+18     	; 0x1816 <__mulsf3+0x72>
    1804:	20 e0       	ldi	r18, 0x00	; 0
    1806:	9a 85       	ldd	r25, Y+10	; 0x0a
    1808:	8a 89       	ldd	r24, Y+18	; 0x12
    180a:	98 13       	cpse	r25, r24
    180c:	21 e0       	ldi	r18, 0x01	; 1
    180e:	2a 87       	std	Y+10, r18	; 0x0a
    1810:	ce 01       	movw	r24, r28
    1812:	09 96       	adiw	r24, 0x09	; 9
    1814:	bb c0       	rjmp	.+374    	; 0x198c <__mulsf3+0x1e8>
    1816:	82 30       	cpi	r24, 0x02	; 2
    1818:	49 f4       	brne	.+18     	; 0x182c <__mulsf3+0x88>
    181a:	20 e0       	ldi	r18, 0x00	; 0
    181c:	9a 85       	ldd	r25, Y+10	; 0x0a
    181e:	8a 89       	ldd	r24, Y+18	; 0x12
    1820:	98 13       	cpse	r25, r24
    1822:	21 e0       	ldi	r18, 0x01	; 1
    1824:	2a 8b       	std	Y+18, r18	; 0x12
    1826:	ce 01       	movw	r24, r28
    1828:	41 96       	adiw	r24, 0x11	; 17
    182a:	b0 c0       	rjmp	.+352    	; 0x198c <__mulsf3+0x1e8>
    182c:	2d 84       	ldd	r2, Y+13	; 0x0d
    182e:	3e 84       	ldd	r3, Y+14	; 0x0e
    1830:	4f 84       	ldd	r4, Y+15	; 0x0f
    1832:	58 88       	ldd	r5, Y+16	; 0x10
    1834:	6d 88       	ldd	r6, Y+21	; 0x15
    1836:	7e 88       	ldd	r7, Y+22	; 0x16
    1838:	8f 88       	ldd	r8, Y+23	; 0x17
    183a:	98 8c       	ldd	r9, Y+24	; 0x18
    183c:	ee 24       	eor	r14, r14
    183e:	ff 24       	eor	r15, r15
    1840:	87 01       	movw	r16, r14
    1842:	aa 24       	eor	r10, r10
    1844:	bb 24       	eor	r11, r11
    1846:	65 01       	movw	r12, r10
    1848:	40 e0       	ldi	r20, 0x00	; 0
    184a:	50 e0       	ldi	r21, 0x00	; 0
    184c:	60 e0       	ldi	r22, 0x00	; 0
    184e:	70 e0       	ldi	r23, 0x00	; 0
    1850:	e0 e0       	ldi	r30, 0x00	; 0
    1852:	f0 e0       	ldi	r31, 0x00	; 0
    1854:	c1 01       	movw	r24, r2
    1856:	81 70       	andi	r24, 0x01	; 1
    1858:	90 70       	andi	r25, 0x00	; 0
    185a:	89 2b       	or	r24, r25
    185c:	e9 f0       	breq	.+58     	; 0x1898 <__mulsf3+0xf4>
    185e:	e6 0c       	add	r14, r6
    1860:	f7 1c       	adc	r15, r7
    1862:	08 1d       	adc	r16, r8
    1864:	19 1d       	adc	r17, r9
    1866:	9a 01       	movw	r18, r20
    1868:	ab 01       	movw	r20, r22
    186a:	2a 0d       	add	r18, r10
    186c:	3b 1d       	adc	r19, r11
    186e:	4c 1d       	adc	r20, r12
    1870:	5d 1d       	adc	r21, r13
    1872:	80 e0       	ldi	r24, 0x00	; 0
    1874:	90 e0       	ldi	r25, 0x00	; 0
    1876:	a0 e0       	ldi	r26, 0x00	; 0
    1878:	b0 e0       	ldi	r27, 0x00	; 0
    187a:	e6 14       	cp	r14, r6
    187c:	f7 04       	cpc	r15, r7
    187e:	08 05       	cpc	r16, r8
    1880:	19 05       	cpc	r17, r9
    1882:	20 f4       	brcc	.+8      	; 0x188c <__mulsf3+0xe8>
    1884:	81 e0       	ldi	r24, 0x01	; 1
    1886:	90 e0       	ldi	r25, 0x00	; 0
    1888:	a0 e0       	ldi	r26, 0x00	; 0
    188a:	b0 e0       	ldi	r27, 0x00	; 0
    188c:	ba 01       	movw	r22, r20
    188e:	a9 01       	movw	r20, r18
    1890:	48 0f       	add	r20, r24
    1892:	59 1f       	adc	r21, r25
    1894:	6a 1f       	adc	r22, r26
    1896:	7b 1f       	adc	r23, r27
    1898:	aa 0c       	add	r10, r10
    189a:	bb 1c       	adc	r11, r11
    189c:	cc 1c       	adc	r12, r12
    189e:	dd 1c       	adc	r13, r13
    18a0:	97 fe       	sbrs	r9, 7
    18a2:	08 c0       	rjmp	.+16     	; 0x18b4 <__mulsf3+0x110>
    18a4:	81 e0       	ldi	r24, 0x01	; 1
    18a6:	90 e0       	ldi	r25, 0x00	; 0
    18a8:	a0 e0       	ldi	r26, 0x00	; 0
    18aa:	b0 e0       	ldi	r27, 0x00	; 0
    18ac:	a8 2a       	or	r10, r24
    18ae:	b9 2a       	or	r11, r25
    18b0:	ca 2a       	or	r12, r26
    18b2:	db 2a       	or	r13, r27
    18b4:	31 96       	adiw	r30, 0x01	; 1
    18b6:	e0 32       	cpi	r30, 0x20	; 32
    18b8:	f1 05       	cpc	r31, r1
    18ba:	49 f0       	breq	.+18     	; 0x18ce <__mulsf3+0x12a>
    18bc:	66 0c       	add	r6, r6
    18be:	77 1c       	adc	r7, r7
    18c0:	88 1c       	adc	r8, r8
    18c2:	99 1c       	adc	r9, r9
    18c4:	56 94       	lsr	r5
    18c6:	47 94       	ror	r4
    18c8:	37 94       	ror	r3
    18ca:	27 94       	ror	r2
    18cc:	c3 cf       	rjmp	.-122    	; 0x1854 <__mulsf3+0xb0>
    18ce:	fa 85       	ldd	r31, Y+10	; 0x0a
    18d0:	ea 89       	ldd	r30, Y+18	; 0x12
    18d2:	2b 89       	ldd	r18, Y+19	; 0x13
    18d4:	3c 89       	ldd	r19, Y+20	; 0x14
    18d6:	8b 85       	ldd	r24, Y+11	; 0x0b
    18d8:	9c 85       	ldd	r25, Y+12	; 0x0c
    18da:	28 0f       	add	r18, r24
    18dc:	39 1f       	adc	r19, r25
    18de:	2e 5f       	subi	r18, 0xFE	; 254
    18e0:	3f 4f       	sbci	r19, 0xFF	; 255
    18e2:	17 c0       	rjmp	.+46     	; 0x1912 <__mulsf3+0x16e>
    18e4:	ca 01       	movw	r24, r20
    18e6:	81 70       	andi	r24, 0x01	; 1
    18e8:	90 70       	andi	r25, 0x00	; 0
    18ea:	89 2b       	or	r24, r25
    18ec:	61 f0       	breq	.+24     	; 0x1906 <__mulsf3+0x162>
    18ee:	16 95       	lsr	r17
    18f0:	07 95       	ror	r16
    18f2:	f7 94       	ror	r15
    18f4:	e7 94       	ror	r14
    18f6:	80 e0       	ldi	r24, 0x00	; 0
    18f8:	90 e0       	ldi	r25, 0x00	; 0
    18fa:	a0 e0       	ldi	r26, 0x00	; 0
    18fc:	b0 e8       	ldi	r27, 0x80	; 128
    18fe:	e8 2a       	or	r14, r24
    1900:	f9 2a       	or	r15, r25
    1902:	0a 2b       	or	r16, r26
    1904:	1b 2b       	or	r17, r27
    1906:	76 95       	lsr	r23
    1908:	67 95       	ror	r22
    190a:	57 95       	ror	r21
    190c:	47 95       	ror	r20
    190e:	2f 5f       	subi	r18, 0xFF	; 255
    1910:	3f 4f       	sbci	r19, 0xFF	; 255
    1912:	77 fd       	sbrc	r23, 7
    1914:	e7 cf       	rjmp	.-50     	; 0x18e4 <__mulsf3+0x140>
    1916:	0c c0       	rjmp	.+24     	; 0x1930 <__mulsf3+0x18c>
    1918:	44 0f       	add	r20, r20
    191a:	55 1f       	adc	r21, r21
    191c:	66 1f       	adc	r22, r22
    191e:	77 1f       	adc	r23, r23
    1920:	17 fd       	sbrc	r17, 7
    1922:	41 60       	ori	r20, 0x01	; 1
    1924:	ee 0c       	add	r14, r14
    1926:	ff 1c       	adc	r15, r15
    1928:	00 1f       	adc	r16, r16
    192a:	11 1f       	adc	r17, r17
    192c:	21 50       	subi	r18, 0x01	; 1
    192e:	30 40       	sbci	r19, 0x00	; 0
    1930:	40 30       	cpi	r20, 0x00	; 0
    1932:	90 e0       	ldi	r25, 0x00	; 0
    1934:	59 07       	cpc	r21, r25
    1936:	90 e0       	ldi	r25, 0x00	; 0
    1938:	69 07       	cpc	r22, r25
    193a:	90 e4       	ldi	r25, 0x40	; 64
    193c:	79 07       	cpc	r23, r25
    193e:	60 f3       	brcs	.-40     	; 0x1918 <__mulsf3+0x174>
    1940:	2b 8f       	std	Y+27, r18	; 0x1b
    1942:	3c 8f       	std	Y+28, r19	; 0x1c
    1944:	db 01       	movw	r26, r22
    1946:	ca 01       	movw	r24, r20
    1948:	8f 77       	andi	r24, 0x7F	; 127
    194a:	90 70       	andi	r25, 0x00	; 0
    194c:	a0 70       	andi	r26, 0x00	; 0
    194e:	b0 70       	andi	r27, 0x00	; 0
    1950:	80 34       	cpi	r24, 0x40	; 64
    1952:	91 05       	cpc	r25, r1
    1954:	a1 05       	cpc	r26, r1
    1956:	b1 05       	cpc	r27, r1
    1958:	61 f4       	brne	.+24     	; 0x1972 <__mulsf3+0x1ce>
    195a:	47 fd       	sbrc	r20, 7
    195c:	0a c0       	rjmp	.+20     	; 0x1972 <__mulsf3+0x1ce>
    195e:	e1 14       	cp	r14, r1
    1960:	f1 04       	cpc	r15, r1
    1962:	01 05       	cpc	r16, r1
    1964:	11 05       	cpc	r17, r1
    1966:	29 f0       	breq	.+10     	; 0x1972 <__mulsf3+0x1ce>
    1968:	40 5c       	subi	r20, 0xC0	; 192
    196a:	5f 4f       	sbci	r21, 0xFF	; 255
    196c:	6f 4f       	sbci	r22, 0xFF	; 255
    196e:	7f 4f       	sbci	r23, 0xFF	; 255
    1970:	40 78       	andi	r20, 0x80	; 128
    1972:	1a 8e       	std	Y+26, r1	; 0x1a
    1974:	fe 17       	cp	r31, r30
    1976:	11 f0       	breq	.+4      	; 0x197c <__mulsf3+0x1d8>
    1978:	81 e0       	ldi	r24, 0x01	; 1
    197a:	8a 8f       	std	Y+26, r24	; 0x1a
    197c:	4d 8f       	std	Y+29, r20	; 0x1d
    197e:	5e 8f       	std	Y+30, r21	; 0x1e
    1980:	6f 8f       	std	Y+31, r22	; 0x1f
    1982:	78 a3       	std	Y+32, r23	; 0x20
    1984:	83 e0       	ldi	r24, 0x03	; 3
    1986:	89 8f       	std	Y+25, r24	; 0x19
    1988:	ce 01       	movw	r24, r28
    198a:	49 96       	adiw	r24, 0x19	; 25
    198c:	0e 94 b0 0d 	call	0x1b60	; 0x1b60 <__pack_f>
    1990:	a0 96       	adiw	r28, 0x20	; 32
    1992:	e2 e1       	ldi	r30, 0x12	; 18
    1994:	0c 94 86 0f 	jmp	0x1f0c	; 0x1f0c <__epilogue_restores__>

00001998 <__gtsf2>:
    1998:	a8 e1       	ldi	r26, 0x18	; 24
    199a:	b0 e0       	ldi	r27, 0x00	; 0
    199c:	e2 ed       	ldi	r30, 0xD2	; 210
    199e:	fc e0       	ldi	r31, 0x0C	; 12
    19a0:	0c 94 76 0f 	jmp	0x1eec	; 0x1eec <__prologue_saves__+0x18>
    19a4:	69 83       	std	Y+1, r22	; 0x01
    19a6:	7a 83       	std	Y+2, r23	; 0x02
    19a8:	8b 83       	std	Y+3, r24	; 0x03
    19aa:	9c 83       	std	Y+4, r25	; 0x04
    19ac:	2d 83       	std	Y+5, r18	; 0x05
    19ae:	3e 83       	std	Y+6, r19	; 0x06
    19b0:	4f 83       	std	Y+7, r20	; 0x07
    19b2:	58 87       	std	Y+8, r21	; 0x08
    19b4:	89 e0       	ldi	r24, 0x09	; 9
    19b6:	e8 2e       	mov	r14, r24
    19b8:	f1 2c       	mov	r15, r1
    19ba:	ec 0e       	add	r14, r28
    19bc:	fd 1e       	adc	r15, r29
    19be:	ce 01       	movw	r24, r28
    19c0:	01 96       	adiw	r24, 0x01	; 1
    19c2:	b7 01       	movw	r22, r14
    19c4:	0e 94 85 0e 	call	0x1d0a	; 0x1d0a <__unpack_f>
    19c8:	8e 01       	movw	r16, r28
    19ca:	0f 5e       	subi	r16, 0xEF	; 239
    19cc:	1f 4f       	sbci	r17, 0xFF	; 255
    19ce:	ce 01       	movw	r24, r28
    19d0:	05 96       	adiw	r24, 0x05	; 5
    19d2:	b8 01       	movw	r22, r16
    19d4:	0e 94 85 0e 	call	0x1d0a	; 0x1d0a <__unpack_f>
    19d8:	89 85       	ldd	r24, Y+9	; 0x09
    19da:	82 30       	cpi	r24, 0x02	; 2
    19dc:	40 f0       	brcs	.+16     	; 0x19ee <__gtsf2+0x56>
    19de:	89 89       	ldd	r24, Y+17	; 0x11
    19e0:	82 30       	cpi	r24, 0x02	; 2
    19e2:	28 f0       	brcs	.+10     	; 0x19ee <__gtsf2+0x56>
    19e4:	c7 01       	movw	r24, r14
    19e6:	b8 01       	movw	r22, r16
    19e8:	0e 94 fd 0e 	call	0x1dfa	; 0x1dfa <__fpcmp_parts_f>
    19ec:	01 c0       	rjmp	.+2      	; 0x19f0 <__gtsf2+0x58>
    19ee:	8f ef       	ldi	r24, 0xFF	; 255
    19f0:	68 96       	adiw	r28, 0x18	; 24
    19f2:	e6 e0       	ldi	r30, 0x06	; 6
    19f4:	0c 94 92 0f 	jmp	0x1f24	; 0x1f24 <__epilogue_restores__+0x18>

000019f8 <__gesf2>:
    19f8:	a8 e1       	ldi	r26, 0x18	; 24
    19fa:	b0 e0       	ldi	r27, 0x00	; 0
    19fc:	e2 e0       	ldi	r30, 0x02	; 2
    19fe:	fd e0       	ldi	r31, 0x0D	; 13
    1a00:	0c 94 76 0f 	jmp	0x1eec	; 0x1eec <__prologue_saves__+0x18>
    1a04:	69 83       	std	Y+1, r22	; 0x01
    1a06:	7a 83       	std	Y+2, r23	; 0x02
    1a08:	8b 83       	std	Y+3, r24	; 0x03
    1a0a:	9c 83       	std	Y+4, r25	; 0x04
    1a0c:	2d 83       	std	Y+5, r18	; 0x05
    1a0e:	3e 83       	std	Y+6, r19	; 0x06
    1a10:	4f 83       	std	Y+7, r20	; 0x07
    1a12:	58 87       	std	Y+8, r21	; 0x08
    1a14:	89 e0       	ldi	r24, 0x09	; 9
    1a16:	e8 2e       	mov	r14, r24
    1a18:	f1 2c       	mov	r15, r1
    1a1a:	ec 0e       	add	r14, r28
    1a1c:	fd 1e       	adc	r15, r29
    1a1e:	ce 01       	movw	r24, r28
    1a20:	01 96       	adiw	r24, 0x01	; 1
    1a22:	b7 01       	movw	r22, r14
    1a24:	0e 94 85 0e 	call	0x1d0a	; 0x1d0a <__unpack_f>
    1a28:	8e 01       	movw	r16, r28
    1a2a:	0f 5e       	subi	r16, 0xEF	; 239
    1a2c:	1f 4f       	sbci	r17, 0xFF	; 255
    1a2e:	ce 01       	movw	r24, r28
    1a30:	05 96       	adiw	r24, 0x05	; 5
    1a32:	b8 01       	movw	r22, r16
    1a34:	0e 94 85 0e 	call	0x1d0a	; 0x1d0a <__unpack_f>
    1a38:	89 85       	ldd	r24, Y+9	; 0x09
    1a3a:	82 30       	cpi	r24, 0x02	; 2
    1a3c:	40 f0       	brcs	.+16     	; 0x1a4e <__gesf2+0x56>
    1a3e:	89 89       	ldd	r24, Y+17	; 0x11
    1a40:	82 30       	cpi	r24, 0x02	; 2
    1a42:	28 f0       	brcs	.+10     	; 0x1a4e <__gesf2+0x56>
    1a44:	c7 01       	movw	r24, r14
    1a46:	b8 01       	movw	r22, r16
    1a48:	0e 94 fd 0e 	call	0x1dfa	; 0x1dfa <__fpcmp_parts_f>
    1a4c:	01 c0       	rjmp	.+2      	; 0x1a50 <__gesf2+0x58>
    1a4e:	8f ef       	ldi	r24, 0xFF	; 255
    1a50:	68 96       	adiw	r28, 0x18	; 24
    1a52:	e6 e0       	ldi	r30, 0x06	; 6
    1a54:	0c 94 92 0f 	jmp	0x1f24	; 0x1f24 <__epilogue_restores__+0x18>

00001a58 <__ltsf2>:
    1a58:	a8 e1       	ldi	r26, 0x18	; 24
    1a5a:	b0 e0       	ldi	r27, 0x00	; 0
    1a5c:	e2 e3       	ldi	r30, 0x32	; 50
    1a5e:	fd e0       	ldi	r31, 0x0D	; 13
    1a60:	0c 94 76 0f 	jmp	0x1eec	; 0x1eec <__prologue_saves__+0x18>
    1a64:	69 83       	std	Y+1, r22	; 0x01
    1a66:	7a 83       	std	Y+2, r23	; 0x02
    1a68:	8b 83       	std	Y+3, r24	; 0x03
    1a6a:	9c 83       	std	Y+4, r25	; 0x04
    1a6c:	2d 83       	std	Y+5, r18	; 0x05
    1a6e:	3e 83       	std	Y+6, r19	; 0x06
    1a70:	4f 83       	std	Y+7, r20	; 0x07
    1a72:	58 87       	std	Y+8, r21	; 0x08
    1a74:	89 e0       	ldi	r24, 0x09	; 9
    1a76:	e8 2e       	mov	r14, r24
    1a78:	f1 2c       	mov	r15, r1
    1a7a:	ec 0e       	add	r14, r28
    1a7c:	fd 1e       	adc	r15, r29
    1a7e:	ce 01       	movw	r24, r28
    1a80:	01 96       	adiw	r24, 0x01	; 1
    1a82:	b7 01       	movw	r22, r14
    1a84:	0e 94 85 0e 	call	0x1d0a	; 0x1d0a <__unpack_f>
    1a88:	8e 01       	movw	r16, r28
    1a8a:	0f 5e       	subi	r16, 0xEF	; 239
    1a8c:	1f 4f       	sbci	r17, 0xFF	; 255
    1a8e:	ce 01       	movw	r24, r28
    1a90:	05 96       	adiw	r24, 0x05	; 5
    1a92:	b8 01       	movw	r22, r16
    1a94:	0e 94 85 0e 	call	0x1d0a	; 0x1d0a <__unpack_f>
    1a98:	89 85       	ldd	r24, Y+9	; 0x09
    1a9a:	82 30       	cpi	r24, 0x02	; 2
    1a9c:	40 f0       	brcs	.+16     	; 0x1aae <__ltsf2+0x56>
    1a9e:	89 89       	ldd	r24, Y+17	; 0x11
    1aa0:	82 30       	cpi	r24, 0x02	; 2
    1aa2:	28 f0       	brcs	.+10     	; 0x1aae <__ltsf2+0x56>
    1aa4:	c7 01       	movw	r24, r14
    1aa6:	b8 01       	movw	r22, r16
    1aa8:	0e 94 fd 0e 	call	0x1dfa	; 0x1dfa <__fpcmp_parts_f>
    1aac:	01 c0       	rjmp	.+2      	; 0x1ab0 <__ltsf2+0x58>
    1aae:	81 e0       	ldi	r24, 0x01	; 1
    1ab0:	68 96       	adiw	r28, 0x18	; 24
    1ab2:	e6 e0       	ldi	r30, 0x06	; 6
    1ab4:	0c 94 92 0f 	jmp	0x1f24	; 0x1f24 <__epilogue_restores__+0x18>

00001ab8 <__fixsfsi>:
    1ab8:	ac e0       	ldi	r26, 0x0C	; 12
    1aba:	b0 e0       	ldi	r27, 0x00	; 0
    1abc:	e2 e6       	ldi	r30, 0x62	; 98
    1abe:	fd e0       	ldi	r31, 0x0D	; 13
    1ac0:	0c 94 7a 0f 	jmp	0x1ef4	; 0x1ef4 <__prologue_saves__+0x20>
    1ac4:	69 83       	std	Y+1, r22	; 0x01
    1ac6:	7a 83       	std	Y+2, r23	; 0x02
    1ac8:	8b 83       	std	Y+3, r24	; 0x03
    1aca:	9c 83       	std	Y+4, r25	; 0x04
    1acc:	ce 01       	movw	r24, r28
    1ace:	01 96       	adiw	r24, 0x01	; 1
    1ad0:	be 01       	movw	r22, r28
    1ad2:	6b 5f       	subi	r22, 0xFB	; 251
    1ad4:	7f 4f       	sbci	r23, 0xFF	; 255
    1ad6:	0e 94 85 0e 	call	0x1d0a	; 0x1d0a <__unpack_f>
    1ada:	8d 81       	ldd	r24, Y+5	; 0x05
    1adc:	82 30       	cpi	r24, 0x02	; 2
    1ade:	61 f1       	breq	.+88     	; 0x1b38 <__fixsfsi+0x80>
    1ae0:	82 30       	cpi	r24, 0x02	; 2
    1ae2:	50 f1       	brcs	.+84     	; 0x1b38 <__fixsfsi+0x80>
    1ae4:	84 30       	cpi	r24, 0x04	; 4
    1ae6:	21 f4       	brne	.+8      	; 0x1af0 <__fixsfsi+0x38>
    1ae8:	8e 81       	ldd	r24, Y+6	; 0x06
    1aea:	88 23       	and	r24, r24
    1aec:	51 f1       	breq	.+84     	; 0x1b42 <__fixsfsi+0x8a>
    1aee:	2e c0       	rjmp	.+92     	; 0x1b4c <__fixsfsi+0x94>
    1af0:	2f 81       	ldd	r18, Y+7	; 0x07
    1af2:	38 85       	ldd	r19, Y+8	; 0x08
    1af4:	37 fd       	sbrc	r19, 7
    1af6:	20 c0       	rjmp	.+64     	; 0x1b38 <__fixsfsi+0x80>
    1af8:	6e 81       	ldd	r22, Y+6	; 0x06
    1afa:	2f 31       	cpi	r18, 0x1F	; 31
    1afc:	31 05       	cpc	r19, r1
    1afe:	1c f0       	brlt	.+6      	; 0x1b06 <__fixsfsi+0x4e>
    1b00:	66 23       	and	r22, r22
    1b02:	f9 f0       	breq	.+62     	; 0x1b42 <__fixsfsi+0x8a>
    1b04:	23 c0       	rjmp	.+70     	; 0x1b4c <__fixsfsi+0x94>
    1b06:	8e e1       	ldi	r24, 0x1E	; 30
    1b08:	90 e0       	ldi	r25, 0x00	; 0
    1b0a:	82 1b       	sub	r24, r18
    1b0c:	93 0b       	sbc	r25, r19
    1b0e:	29 85       	ldd	r18, Y+9	; 0x09
    1b10:	3a 85       	ldd	r19, Y+10	; 0x0a
    1b12:	4b 85       	ldd	r20, Y+11	; 0x0b
    1b14:	5c 85       	ldd	r21, Y+12	; 0x0c
    1b16:	04 c0       	rjmp	.+8      	; 0x1b20 <__fixsfsi+0x68>
    1b18:	56 95       	lsr	r21
    1b1a:	47 95       	ror	r20
    1b1c:	37 95       	ror	r19
    1b1e:	27 95       	ror	r18
    1b20:	8a 95       	dec	r24
    1b22:	d2 f7       	brpl	.-12     	; 0x1b18 <__fixsfsi+0x60>
    1b24:	66 23       	and	r22, r22
    1b26:	b1 f0       	breq	.+44     	; 0x1b54 <__fixsfsi+0x9c>
    1b28:	50 95       	com	r21
    1b2a:	40 95       	com	r20
    1b2c:	30 95       	com	r19
    1b2e:	21 95       	neg	r18
    1b30:	3f 4f       	sbci	r19, 0xFF	; 255
    1b32:	4f 4f       	sbci	r20, 0xFF	; 255
    1b34:	5f 4f       	sbci	r21, 0xFF	; 255
    1b36:	0e c0       	rjmp	.+28     	; 0x1b54 <__fixsfsi+0x9c>
    1b38:	20 e0       	ldi	r18, 0x00	; 0
    1b3a:	30 e0       	ldi	r19, 0x00	; 0
    1b3c:	40 e0       	ldi	r20, 0x00	; 0
    1b3e:	50 e0       	ldi	r21, 0x00	; 0
    1b40:	09 c0       	rjmp	.+18     	; 0x1b54 <__fixsfsi+0x9c>
    1b42:	2f ef       	ldi	r18, 0xFF	; 255
    1b44:	3f ef       	ldi	r19, 0xFF	; 255
    1b46:	4f ef       	ldi	r20, 0xFF	; 255
    1b48:	5f e7       	ldi	r21, 0x7F	; 127
    1b4a:	04 c0       	rjmp	.+8      	; 0x1b54 <__fixsfsi+0x9c>
    1b4c:	20 e0       	ldi	r18, 0x00	; 0
    1b4e:	30 e0       	ldi	r19, 0x00	; 0
    1b50:	40 e0       	ldi	r20, 0x00	; 0
    1b52:	50 e8       	ldi	r21, 0x80	; 128
    1b54:	b9 01       	movw	r22, r18
    1b56:	ca 01       	movw	r24, r20
    1b58:	2c 96       	adiw	r28, 0x0c	; 12
    1b5a:	e2 e0       	ldi	r30, 0x02	; 2
    1b5c:	0c 94 96 0f 	jmp	0x1f2c	; 0x1f2c <__epilogue_restores__+0x20>

00001b60 <__pack_f>:
    1b60:	df 92       	push	r13
    1b62:	ef 92       	push	r14
    1b64:	ff 92       	push	r15
    1b66:	0f 93       	push	r16
    1b68:	1f 93       	push	r17
    1b6a:	fc 01       	movw	r30, r24
    1b6c:	e4 80       	ldd	r14, Z+4	; 0x04
    1b6e:	f5 80       	ldd	r15, Z+5	; 0x05
    1b70:	06 81       	ldd	r16, Z+6	; 0x06
    1b72:	17 81       	ldd	r17, Z+7	; 0x07
    1b74:	d1 80       	ldd	r13, Z+1	; 0x01
    1b76:	80 81       	ld	r24, Z
    1b78:	82 30       	cpi	r24, 0x02	; 2
    1b7a:	48 f4       	brcc	.+18     	; 0x1b8e <__pack_f+0x2e>
    1b7c:	80 e0       	ldi	r24, 0x00	; 0
    1b7e:	90 e0       	ldi	r25, 0x00	; 0
    1b80:	a0 e1       	ldi	r26, 0x10	; 16
    1b82:	b0 e0       	ldi	r27, 0x00	; 0
    1b84:	e8 2a       	or	r14, r24
    1b86:	f9 2a       	or	r15, r25
    1b88:	0a 2b       	or	r16, r26
    1b8a:	1b 2b       	or	r17, r27
    1b8c:	a5 c0       	rjmp	.+330    	; 0x1cd8 <__pack_f+0x178>
    1b8e:	84 30       	cpi	r24, 0x04	; 4
    1b90:	09 f4       	brne	.+2      	; 0x1b94 <__pack_f+0x34>
    1b92:	9f c0       	rjmp	.+318    	; 0x1cd2 <__pack_f+0x172>
    1b94:	82 30       	cpi	r24, 0x02	; 2
    1b96:	21 f4       	brne	.+8      	; 0x1ba0 <__pack_f+0x40>
    1b98:	ee 24       	eor	r14, r14
    1b9a:	ff 24       	eor	r15, r15
    1b9c:	87 01       	movw	r16, r14
    1b9e:	05 c0       	rjmp	.+10     	; 0x1baa <__pack_f+0x4a>
    1ba0:	e1 14       	cp	r14, r1
    1ba2:	f1 04       	cpc	r15, r1
    1ba4:	01 05       	cpc	r16, r1
    1ba6:	11 05       	cpc	r17, r1
    1ba8:	19 f4       	brne	.+6      	; 0x1bb0 <__pack_f+0x50>
    1baa:	e0 e0       	ldi	r30, 0x00	; 0
    1bac:	f0 e0       	ldi	r31, 0x00	; 0
    1bae:	96 c0       	rjmp	.+300    	; 0x1cdc <__pack_f+0x17c>
    1bb0:	62 81       	ldd	r22, Z+2	; 0x02
    1bb2:	73 81       	ldd	r23, Z+3	; 0x03
    1bb4:	9f ef       	ldi	r25, 0xFF	; 255
    1bb6:	62 38       	cpi	r22, 0x82	; 130
    1bb8:	79 07       	cpc	r23, r25
    1bba:	0c f0       	brlt	.+2      	; 0x1bbe <__pack_f+0x5e>
    1bbc:	5b c0       	rjmp	.+182    	; 0x1c74 <__pack_f+0x114>
    1bbe:	22 e8       	ldi	r18, 0x82	; 130
    1bc0:	3f ef       	ldi	r19, 0xFF	; 255
    1bc2:	26 1b       	sub	r18, r22
    1bc4:	37 0b       	sbc	r19, r23
    1bc6:	2a 31       	cpi	r18, 0x1A	; 26
    1bc8:	31 05       	cpc	r19, r1
    1bca:	2c f0       	brlt	.+10     	; 0x1bd6 <__pack_f+0x76>
    1bcc:	20 e0       	ldi	r18, 0x00	; 0
    1bce:	30 e0       	ldi	r19, 0x00	; 0
    1bd0:	40 e0       	ldi	r20, 0x00	; 0
    1bd2:	50 e0       	ldi	r21, 0x00	; 0
    1bd4:	2a c0       	rjmp	.+84     	; 0x1c2a <__pack_f+0xca>
    1bd6:	b8 01       	movw	r22, r16
    1bd8:	a7 01       	movw	r20, r14
    1bda:	02 2e       	mov	r0, r18
    1bdc:	04 c0       	rjmp	.+8      	; 0x1be6 <__pack_f+0x86>
    1bde:	76 95       	lsr	r23
    1be0:	67 95       	ror	r22
    1be2:	57 95       	ror	r21
    1be4:	47 95       	ror	r20
    1be6:	0a 94       	dec	r0
    1be8:	d2 f7       	brpl	.-12     	; 0x1bde <__pack_f+0x7e>
    1bea:	81 e0       	ldi	r24, 0x01	; 1
    1bec:	90 e0       	ldi	r25, 0x00	; 0
    1bee:	a0 e0       	ldi	r26, 0x00	; 0
    1bf0:	b0 e0       	ldi	r27, 0x00	; 0
    1bf2:	04 c0       	rjmp	.+8      	; 0x1bfc <__pack_f+0x9c>
    1bf4:	88 0f       	add	r24, r24
    1bf6:	99 1f       	adc	r25, r25
    1bf8:	aa 1f       	adc	r26, r26
    1bfa:	bb 1f       	adc	r27, r27
    1bfc:	2a 95       	dec	r18
    1bfe:	d2 f7       	brpl	.-12     	; 0x1bf4 <__pack_f+0x94>
    1c00:	01 97       	sbiw	r24, 0x01	; 1
    1c02:	a1 09       	sbc	r26, r1
    1c04:	b1 09       	sbc	r27, r1
    1c06:	8e 21       	and	r24, r14
    1c08:	9f 21       	and	r25, r15
    1c0a:	a0 23       	and	r26, r16
    1c0c:	b1 23       	and	r27, r17
    1c0e:	00 97       	sbiw	r24, 0x00	; 0
    1c10:	a1 05       	cpc	r26, r1
    1c12:	b1 05       	cpc	r27, r1
    1c14:	21 f0       	breq	.+8      	; 0x1c1e <__pack_f+0xbe>
    1c16:	81 e0       	ldi	r24, 0x01	; 1
    1c18:	90 e0       	ldi	r25, 0x00	; 0
    1c1a:	a0 e0       	ldi	r26, 0x00	; 0
    1c1c:	b0 e0       	ldi	r27, 0x00	; 0
    1c1e:	9a 01       	movw	r18, r20
    1c20:	ab 01       	movw	r20, r22
    1c22:	28 2b       	or	r18, r24
    1c24:	39 2b       	or	r19, r25
    1c26:	4a 2b       	or	r20, r26
    1c28:	5b 2b       	or	r21, r27
    1c2a:	da 01       	movw	r26, r20
    1c2c:	c9 01       	movw	r24, r18
    1c2e:	8f 77       	andi	r24, 0x7F	; 127
    1c30:	90 70       	andi	r25, 0x00	; 0
    1c32:	a0 70       	andi	r26, 0x00	; 0
    1c34:	b0 70       	andi	r27, 0x00	; 0
    1c36:	80 34       	cpi	r24, 0x40	; 64
    1c38:	91 05       	cpc	r25, r1
    1c3a:	a1 05       	cpc	r26, r1
    1c3c:	b1 05       	cpc	r27, r1
    1c3e:	39 f4       	brne	.+14     	; 0x1c4e <__pack_f+0xee>
    1c40:	27 ff       	sbrs	r18, 7
    1c42:	09 c0       	rjmp	.+18     	; 0x1c56 <__pack_f+0xf6>
    1c44:	20 5c       	subi	r18, 0xC0	; 192
    1c46:	3f 4f       	sbci	r19, 0xFF	; 255
    1c48:	4f 4f       	sbci	r20, 0xFF	; 255
    1c4a:	5f 4f       	sbci	r21, 0xFF	; 255
    1c4c:	04 c0       	rjmp	.+8      	; 0x1c56 <__pack_f+0xf6>
    1c4e:	21 5c       	subi	r18, 0xC1	; 193
    1c50:	3f 4f       	sbci	r19, 0xFF	; 255
    1c52:	4f 4f       	sbci	r20, 0xFF	; 255
    1c54:	5f 4f       	sbci	r21, 0xFF	; 255
    1c56:	e0 e0       	ldi	r30, 0x00	; 0
    1c58:	f0 e0       	ldi	r31, 0x00	; 0
    1c5a:	20 30       	cpi	r18, 0x00	; 0
    1c5c:	a0 e0       	ldi	r26, 0x00	; 0
    1c5e:	3a 07       	cpc	r19, r26
    1c60:	a0 e0       	ldi	r26, 0x00	; 0
    1c62:	4a 07       	cpc	r20, r26
    1c64:	a0 e4       	ldi	r26, 0x40	; 64
    1c66:	5a 07       	cpc	r21, r26
    1c68:	10 f0       	brcs	.+4      	; 0x1c6e <__pack_f+0x10e>
    1c6a:	e1 e0       	ldi	r30, 0x01	; 1
    1c6c:	f0 e0       	ldi	r31, 0x00	; 0
    1c6e:	79 01       	movw	r14, r18
    1c70:	8a 01       	movw	r16, r20
    1c72:	27 c0       	rjmp	.+78     	; 0x1cc2 <__pack_f+0x162>
    1c74:	60 38       	cpi	r22, 0x80	; 128
    1c76:	71 05       	cpc	r23, r1
    1c78:	64 f5       	brge	.+88     	; 0x1cd2 <__pack_f+0x172>
    1c7a:	fb 01       	movw	r30, r22
    1c7c:	e1 58       	subi	r30, 0x81	; 129
    1c7e:	ff 4f       	sbci	r31, 0xFF	; 255
    1c80:	d8 01       	movw	r26, r16
    1c82:	c7 01       	movw	r24, r14
    1c84:	8f 77       	andi	r24, 0x7F	; 127
    1c86:	90 70       	andi	r25, 0x00	; 0
    1c88:	a0 70       	andi	r26, 0x00	; 0
    1c8a:	b0 70       	andi	r27, 0x00	; 0
    1c8c:	80 34       	cpi	r24, 0x40	; 64
    1c8e:	91 05       	cpc	r25, r1
    1c90:	a1 05       	cpc	r26, r1
    1c92:	b1 05       	cpc	r27, r1
    1c94:	39 f4       	brne	.+14     	; 0x1ca4 <__pack_f+0x144>
    1c96:	e7 fe       	sbrs	r14, 7
    1c98:	0d c0       	rjmp	.+26     	; 0x1cb4 <__pack_f+0x154>
    1c9a:	80 e4       	ldi	r24, 0x40	; 64
    1c9c:	90 e0       	ldi	r25, 0x00	; 0
    1c9e:	a0 e0       	ldi	r26, 0x00	; 0
    1ca0:	b0 e0       	ldi	r27, 0x00	; 0
    1ca2:	04 c0       	rjmp	.+8      	; 0x1cac <__pack_f+0x14c>
    1ca4:	8f e3       	ldi	r24, 0x3F	; 63
    1ca6:	90 e0       	ldi	r25, 0x00	; 0
    1ca8:	a0 e0       	ldi	r26, 0x00	; 0
    1caa:	b0 e0       	ldi	r27, 0x00	; 0
    1cac:	e8 0e       	add	r14, r24
    1cae:	f9 1e       	adc	r15, r25
    1cb0:	0a 1f       	adc	r16, r26
    1cb2:	1b 1f       	adc	r17, r27
    1cb4:	17 ff       	sbrs	r17, 7
    1cb6:	05 c0       	rjmp	.+10     	; 0x1cc2 <__pack_f+0x162>
    1cb8:	16 95       	lsr	r17
    1cba:	07 95       	ror	r16
    1cbc:	f7 94       	ror	r15
    1cbe:	e7 94       	ror	r14
    1cc0:	31 96       	adiw	r30, 0x01	; 1
    1cc2:	87 e0       	ldi	r24, 0x07	; 7
    1cc4:	16 95       	lsr	r17
    1cc6:	07 95       	ror	r16
    1cc8:	f7 94       	ror	r15
    1cca:	e7 94       	ror	r14
    1ccc:	8a 95       	dec	r24
    1cce:	d1 f7       	brne	.-12     	; 0x1cc4 <__pack_f+0x164>
    1cd0:	05 c0       	rjmp	.+10     	; 0x1cdc <__pack_f+0x17c>
    1cd2:	ee 24       	eor	r14, r14
    1cd4:	ff 24       	eor	r15, r15
    1cd6:	87 01       	movw	r16, r14
    1cd8:	ef ef       	ldi	r30, 0xFF	; 255
    1cda:	f0 e0       	ldi	r31, 0x00	; 0
    1cdc:	6e 2f       	mov	r22, r30
    1cde:	67 95       	ror	r22
    1ce0:	66 27       	eor	r22, r22
    1ce2:	67 95       	ror	r22
    1ce4:	90 2f       	mov	r25, r16
    1ce6:	9f 77       	andi	r25, 0x7F	; 127
    1ce8:	d7 94       	ror	r13
    1cea:	dd 24       	eor	r13, r13
    1cec:	d7 94       	ror	r13
    1cee:	8e 2f       	mov	r24, r30
    1cf0:	86 95       	lsr	r24
    1cf2:	49 2f       	mov	r20, r25
    1cf4:	46 2b       	or	r20, r22
    1cf6:	58 2f       	mov	r21, r24
    1cf8:	5d 29       	or	r21, r13
    1cfa:	b7 01       	movw	r22, r14
    1cfc:	ca 01       	movw	r24, r20
    1cfe:	1f 91       	pop	r17
    1d00:	0f 91       	pop	r16
    1d02:	ff 90       	pop	r15
    1d04:	ef 90       	pop	r14
    1d06:	df 90       	pop	r13
    1d08:	08 95       	ret

00001d0a <__unpack_f>:
    1d0a:	fc 01       	movw	r30, r24
    1d0c:	db 01       	movw	r26, r22
    1d0e:	40 81       	ld	r20, Z
    1d10:	51 81       	ldd	r21, Z+1	; 0x01
    1d12:	22 81       	ldd	r18, Z+2	; 0x02
    1d14:	62 2f       	mov	r22, r18
    1d16:	6f 77       	andi	r22, 0x7F	; 127
    1d18:	70 e0       	ldi	r23, 0x00	; 0
    1d1a:	22 1f       	adc	r18, r18
    1d1c:	22 27       	eor	r18, r18
    1d1e:	22 1f       	adc	r18, r18
    1d20:	93 81       	ldd	r25, Z+3	; 0x03
    1d22:	89 2f       	mov	r24, r25
    1d24:	88 0f       	add	r24, r24
    1d26:	82 2b       	or	r24, r18
    1d28:	28 2f       	mov	r18, r24
    1d2a:	30 e0       	ldi	r19, 0x00	; 0
    1d2c:	99 1f       	adc	r25, r25
    1d2e:	99 27       	eor	r25, r25
    1d30:	99 1f       	adc	r25, r25
    1d32:	11 96       	adiw	r26, 0x01	; 1
    1d34:	9c 93       	st	X, r25
    1d36:	11 97       	sbiw	r26, 0x01	; 1
    1d38:	21 15       	cp	r18, r1
    1d3a:	31 05       	cpc	r19, r1
    1d3c:	a9 f5       	brne	.+106    	; 0x1da8 <__unpack_f+0x9e>
    1d3e:	41 15       	cp	r20, r1
    1d40:	51 05       	cpc	r21, r1
    1d42:	61 05       	cpc	r22, r1
    1d44:	71 05       	cpc	r23, r1
    1d46:	11 f4       	brne	.+4      	; 0x1d4c <__unpack_f+0x42>
    1d48:	82 e0       	ldi	r24, 0x02	; 2
    1d4a:	37 c0       	rjmp	.+110    	; 0x1dba <__unpack_f+0xb0>
    1d4c:	82 e8       	ldi	r24, 0x82	; 130
    1d4e:	9f ef       	ldi	r25, 0xFF	; 255
    1d50:	13 96       	adiw	r26, 0x03	; 3
    1d52:	9c 93       	st	X, r25
    1d54:	8e 93       	st	-X, r24
    1d56:	12 97       	sbiw	r26, 0x02	; 2
    1d58:	9a 01       	movw	r18, r20
    1d5a:	ab 01       	movw	r20, r22
    1d5c:	67 e0       	ldi	r22, 0x07	; 7
    1d5e:	22 0f       	add	r18, r18
    1d60:	33 1f       	adc	r19, r19
    1d62:	44 1f       	adc	r20, r20
    1d64:	55 1f       	adc	r21, r21
    1d66:	6a 95       	dec	r22
    1d68:	d1 f7       	brne	.-12     	; 0x1d5e <__unpack_f+0x54>
    1d6a:	83 e0       	ldi	r24, 0x03	; 3
    1d6c:	8c 93       	st	X, r24
    1d6e:	0d c0       	rjmp	.+26     	; 0x1d8a <__unpack_f+0x80>
    1d70:	22 0f       	add	r18, r18
    1d72:	33 1f       	adc	r19, r19
    1d74:	44 1f       	adc	r20, r20
    1d76:	55 1f       	adc	r21, r21
    1d78:	12 96       	adiw	r26, 0x02	; 2
    1d7a:	8d 91       	ld	r24, X+
    1d7c:	9c 91       	ld	r25, X
    1d7e:	13 97       	sbiw	r26, 0x03	; 3
    1d80:	01 97       	sbiw	r24, 0x01	; 1
    1d82:	13 96       	adiw	r26, 0x03	; 3
    1d84:	9c 93       	st	X, r25
    1d86:	8e 93       	st	-X, r24
    1d88:	12 97       	sbiw	r26, 0x02	; 2
    1d8a:	20 30       	cpi	r18, 0x00	; 0
    1d8c:	80 e0       	ldi	r24, 0x00	; 0
    1d8e:	38 07       	cpc	r19, r24
    1d90:	80 e0       	ldi	r24, 0x00	; 0
    1d92:	48 07       	cpc	r20, r24
    1d94:	80 e4       	ldi	r24, 0x40	; 64
    1d96:	58 07       	cpc	r21, r24
    1d98:	58 f3       	brcs	.-42     	; 0x1d70 <__unpack_f+0x66>
    1d9a:	14 96       	adiw	r26, 0x04	; 4
    1d9c:	2d 93       	st	X+, r18
    1d9e:	3d 93       	st	X+, r19
    1da0:	4d 93       	st	X+, r20
    1da2:	5c 93       	st	X, r21
    1da4:	17 97       	sbiw	r26, 0x07	; 7
    1da6:	08 95       	ret
    1da8:	2f 3f       	cpi	r18, 0xFF	; 255
    1daa:	31 05       	cpc	r19, r1
    1dac:	79 f4       	brne	.+30     	; 0x1dcc <__unpack_f+0xc2>
    1dae:	41 15       	cp	r20, r1
    1db0:	51 05       	cpc	r21, r1
    1db2:	61 05       	cpc	r22, r1
    1db4:	71 05       	cpc	r23, r1
    1db6:	19 f4       	brne	.+6      	; 0x1dbe <__unpack_f+0xb4>
    1db8:	84 e0       	ldi	r24, 0x04	; 4
    1dba:	8c 93       	st	X, r24
    1dbc:	08 95       	ret
    1dbe:	64 ff       	sbrs	r22, 4
    1dc0:	03 c0       	rjmp	.+6      	; 0x1dc8 <__unpack_f+0xbe>
    1dc2:	81 e0       	ldi	r24, 0x01	; 1
    1dc4:	8c 93       	st	X, r24
    1dc6:	12 c0       	rjmp	.+36     	; 0x1dec <__unpack_f+0xe2>
    1dc8:	1c 92       	st	X, r1
    1dca:	10 c0       	rjmp	.+32     	; 0x1dec <__unpack_f+0xe2>
    1dcc:	2f 57       	subi	r18, 0x7F	; 127
    1dce:	30 40       	sbci	r19, 0x00	; 0
    1dd0:	13 96       	adiw	r26, 0x03	; 3
    1dd2:	3c 93       	st	X, r19
    1dd4:	2e 93       	st	-X, r18
    1dd6:	12 97       	sbiw	r26, 0x02	; 2
    1dd8:	83 e0       	ldi	r24, 0x03	; 3
    1dda:	8c 93       	st	X, r24
    1ddc:	87 e0       	ldi	r24, 0x07	; 7
    1dde:	44 0f       	add	r20, r20
    1de0:	55 1f       	adc	r21, r21
    1de2:	66 1f       	adc	r22, r22
    1de4:	77 1f       	adc	r23, r23
    1de6:	8a 95       	dec	r24
    1de8:	d1 f7       	brne	.-12     	; 0x1dde <__unpack_f+0xd4>
    1dea:	70 64       	ori	r23, 0x40	; 64
    1dec:	14 96       	adiw	r26, 0x04	; 4
    1dee:	4d 93       	st	X+, r20
    1df0:	5d 93       	st	X+, r21
    1df2:	6d 93       	st	X+, r22
    1df4:	7c 93       	st	X, r23
    1df6:	17 97       	sbiw	r26, 0x07	; 7
    1df8:	08 95       	ret

00001dfa <__fpcmp_parts_f>:
    1dfa:	1f 93       	push	r17
    1dfc:	dc 01       	movw	r26, r24
    1dfe:	fb 01       	movw	r30, r22
    1e00:	9c 91       	ld	r25, X
    1e02:	92 30       	cpi	r25, 0x02	; 2
    1e04:	08 f4       	brcc	.+2      	; 0x1e08 <__fpcmp_parts_f+0xe>
    1e06:	47 c0       	rjmp	.+142    	; 0x1e96 <__fpcmp_parts_f+0x9c>
    1e08:	80 81       	ld	r24, Z
    1e0a:	82 30       	cpi	r24, 0x02	; 2
    1e0c:	08 f4       	brcc	.+2      	; 0x1e10 <__fpcmp_parts_f+0x16>
    1e0e:	43 c0       	rjmp	.+134    	; 0x1e96 <__fpcmp_parts_f+0x9c>
    1e10:	94 30       	cpi	r25, 0x04	; 4
    1e12:	51 f4       	brne	.+20     	; 0x1e28 <__fpcmp_parts_f+0x2e>
    1e14:	11 96       	adiw	r26, 0x01	; 1
    1e16:	1c 91       	ld	r17, X
    1e18:	84 30       	cpi	r24, 0x04	; 4
    1e1a:	99 f5       	brne	.+102    	; 0x1e82 <__fpcmp_parts_f+0x88>
    1e1c:	81 81       	ldd	r24, Z+1	; 0x01
    1e1e:	68 2f       	mov	r22, r24
    1e20:	70 e0       	ldi	r23, 0x00	; 0
    1e22:	61 1b       	sub	r22, r17
    1e24:	71 09       	sbc	r23, r1
    1e26:	3f c0       	rjmp	.+126    	; 0x1ea6 <__fpcmp_parts_f+0xac>
    1e28:	84 30       	cpi	r24, 0x04	; 4
    1e2a:	21 f0       	breq	.+8      	; 0x1e34 <__fpcmp_parts_f+0x3a>
    1e2c:	92 30       	cpi	r25, 0x02	; 2
    1e2e:	31 f4       	brne	.+12     	; 0x1e3c <__fpcmp_parts_f+0x42>
    1e30:	82 30       	cpi	r24, 0x02	; 2
    1e32:	b9 f1       	breq	.+110    	; 0x1ea2 <__fpcmp_parts_f+0xa8>
    1e34:	81 81       	ldd	r24, Z+1	; 0x01
    1e36:	88 23       	and	r24, r24
    1e38:	89 f1       	breq	.+98     	; 0x1e9c <__fpcmp_parts_f+0xa2>
    1e3a:	2d c0       	rjmp	.+90     	; 0x1e96 <__fpcmp_parts_f+0x9c>
    1e3c:	11 96       	adiw	r26, 0x01	; 1
    1e3e:	1c 91       	ld	r17, X
    1e40:	11 97       	sbiw	r26, 0x01	; 1
    1e42:	82 30       	cpi	r24, 0x02	; 2
    1e44:	f1 f0       	breq	.+60     	; 0x1e82 <__fpcmp_parts_f+0x88>
    1e46:	81 81       	ldd	r24, Z+1	; 0x01
    1e48:	18 17       	cp	r17, r24
    1e4a:	d9 f4       	brne	.+54     	; 0x1e82 <__fpcmp_parts_f+0x88>
    1e4c:	12 96       	adiw	r26, 0x02	; 2
    1e4e:	2d 91       	ld	r18, X+
    1e50:	3c 91       	ld	r19, X
    1e52:	13 97       	sbiw	r26, 0x03	; 3
    1e54:	82 81       	ldd	r24, Z+2	; 0x02
    1e56:	93 81       	ldd	r25, Z+3	; 0x03
    1e58:	82 17       	cp	r24, r18
    1e5a:	93 07       	cpc	r25, r19
    1e5c:	94 f0       	brlt	.+36     	; 0x1e82 <__fpcmp_parts_f+0x88>
    1e5e:	28 17       	cp	r18, r24
    1e60:	39 07       	cpc	r19, r25
    1e62:	bc f0       	brlt	.+46     	; 0x1e92 <__fpcmp_parts_f+0x98>
    1e64:	14 96       	adiw	r26, 0x04	; 4
    1e66:	8d 91       	ld	r24, X+
    1e68:	9d 91       	ld	r25, X+
    1e6a:	0d 90       	ld	r0, X+
    1e6c:	bc 91       	ld	r27, X
    1e6e:	a0 2d       	mov	r26, r0
    1e70:	24 81       	ldd	r18, Z+4	; 0x04
    1e72:	35 81       	ldd	r19, Z+5	; 0x05
    1e74:	46 81       	ldd	r20, Z+6	; 0x06
    1e76:	57 81       	ldd	r21, Z+7	; 0x07
    1e78:	28 17       	cp	r18, r24
    1e7a:	39 07       	cpc	r19, r25
    1e7c:	4a 07       	cpc	r20, r26
    1e7e:	5b 07       	cpc	r21, r27
    1e80:	18 f4       	brcc	.+6      	; 0x1e88 <__fpcmp_parts_f+0x8e>
    1e82:	11 23       	and	r17, r17
    1e84:	41 f0       	breq	.+16     	; 0x1e96 <__fpcmp_parts_f+0x9c>
    1e86:	0a c0       	rjmp	.+20     	; 0x1e9c <__fpcmp_parts_f+0xa2>
    1e88:	82 17       	cp	r24, r18
    1e8a:	93 07       	cpc	r25, r19
    1e8c:	a4 07       	cpc	r26, r20
    1e8e:	b5 07       	cpc	r27, r21
    1e90:	40 f4       	brcc	.+16     	; 0x1ea2 <__fpcmp_parts_f+0xa8>
    1e92:	11 23       	and	r17, r17
    1e94:	19 f0       	breq	.+6      	; 0x1e9c <__fpcmp_parts_f+0xa2>
    1e96:	61 e0       	ldi	r22, 0x01	; 1
    1e98:	70 e0       	ldi	r23, 0x00	; 0
    1e9a:	05 c0       	rjmp	.+10     	; 0x1ea6 <__fpcmp_parts_f+0xac>
    1e9c:	6f ef       	ldi	r22, 0xFF	; 255
    1e9e:	7f ef       	ldi	r23, 0xFF	; 255
    1ea0:	02 c0       	rjmp	.+4      	; 0x1ea6 <__fpcmp_parts_f+0xac>
    1ea2:	60 e0       	ldi	r22, 0x00	; 0
    1ea4:	70 e0       	ldi	r23, 0x00	; 0
    1ea6:	cb 01       	movw	r24, r22
    1ea8:	1f 91       	pop	r17
    1eaa:	08 95       	ret

00001eac <__udivmodhi4>:
    1eac:	aa 1b       	sub	r26, r26
    1eae:	bb 1b       	sub	r27, r27
    1eb0:	51 e1       	ldi	r21, 0x11	; 17
    1eb2:	07 c0       	rjmp	.+14     	; 0x1ec2 <__udivmodhi4_ep>

00001eb4 <__udivmodhi4_loop>:
    1eb4:	aa 1f       	adc	r26, r26
    1eb6:	bb 1f       	adc	r27, r27
    1eb8:	a6 17       	cp	r26, r22
    1eba:	b7 07       	cpc	r27, r23
    1ebc:	10 f0       	brcs	.+4      	; 0x1ec2 <__udivmodhi4_ep>
    1ebe:	a6 1b       	sub	r26, r22
    1ec0:	b7 0b       	sbc	r27, r23

00001ec2 <__udivmodhi4_ep>:
    1ec2:	88 1f       	adc	r24, r24
    1ec4:	99 1f       	adc	r25, r25
    1ec6:	5a 95       	dec	r21
    1ec8:	a9 f7       	brne	.-22     	; 0x1eb4 <__udivmodhi4_loop>
    1eca:	80 95       	com	r24
    1ecc:	90 95       	com	r25
    1ece:	bc 01       	movw	r22, r24
    1ed0:	cd 01       	movw	r24, r26
    1ed2:	08 95       	ret

00001ed4 <__prologue_saves__>:
    1ed4:	2f 92       	push	r2
    1ed6:	3f 92       	push	r3
    1ed8:	4f 92       	push	r4
    1eda:	5f 92       	push	r5
    1edc:	6f 92       	push	r6
    1ede:	7f 92       	push	r7
    1ee0:	8f 92       	push	r8
    1ee2:	9f 92       	push	r9
    1ee4:	af 92       	push	r10
    1ee6:	bf 92       	push	r11
    1ee8:	cf 92       	push	r12
    1eea:	df 92       	push	r13
    1eec:	ef 92       	push	r14
    1eee:	ff 92       	push	r15
    1ef0:	0f 93       	push	r16
    1ef2:	1f 93       	push	r17
    1ef4:	cf 93       	push	r28
    1ef6:	df 93       	push	r29
    1ef8:	cd b7       	in	r28, 0x3d	; 61
    1efa:	de b7       	in	r29, 0x3e	; 62
    1efc:	ca 1b       	sub	r28, r26
    1efe:	db 0b       	sbc	r29, r27
    1f00:	0f b6       	in	r0, 0x3f	; 63
    1f02:	f8 94       	cli
    1f04:	de bf       	out	0x3e, r29	; 62
    1f06:	0f be       	out	0x3f, r0	; 63
    1f08:	cd bf       	out	0x3d, r28	; 61
    1f0a:	09 94       	ijmp

00001f0c <__epilogue_restores__>:
    1f0c:	2a 88       	ldd	r2, Y+18	; 0x12
    1f0e:	39 88       	ldd	r3, Y+17	; 0x11
    1f10:	48 88       	ldd	r4, Y+16	; 0x10
    1f12:	5f 84       	ldd	r5, Y+15	; 0x0f
    1f14:	6e 84       	ldd	r6, Y+14	; 0x0e
    1f16:	7d 84       	ldd	r7, Y+13	; 0x0d
    1f18:	8c 84       	ldd	r8, Y+12	; 0x0c
    1f1a:	9b 84       	ldd	r9, Y+11	; 0x0b
    1f1c:	aa 84       	ldd	r10, Y+10	; 0x0a
    1f1e:	b9 84       	ldd	r11, Y+9	; 0x09
    1f20:	c8 84       	ldd	r12, Y+8	; 0x08
    1f22:	df 80       	ldd	r13, Y+7	; 0x07
    1f24:	ee 80       	ldd	r14, Y+6	; 0x06
    1f26:	fd 80       	ldd	r15, Y+5	; 0x05
    1f28:	0c 81       	ldd	r16, Y+4	; 0x04
    1f2a:	1b 81       	ldd	r17, Y+3	; 0x03
    1f2c:	aa 81       	ldd	r26, Y+2	; 0x02
    1f2e:	b9 81       	ldd	r27, Y+1	; 0x01
    1f30:	ce 0f       	add	r28, r30
    1f32:	d1 1d       	adc	r29, r1
    1f34:	0f b6       	in	r0, 0x3f	; 63
    1f36:	f8 94       	cli
    1f38:	de bf       	out	0x3e, r29	; 62
    1f3a:	0f be       	out	0x3f, r0	; 63
    1f3c:	cd bf       	out	0x3d, r28	; 61
    1f3e:	ed 01       	movw	r28, r26
    1f40:	08 95       	ret

00001f42 <_exit>:
    1f42:	f8 94       	cli

00001f44 <__stop_program>:
    1f44:	ff cf       	rjmp	.-2      	; 0x1f44 <__stop_program>
